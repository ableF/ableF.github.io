<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:type" content="website">
<meta property="og:title" content="无名之辈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="无名之辈">
<meta property="og:description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="前端一岁小白-able.Feng">
<meta name="twitter:card" content="summary"><meta name="keywords" content="前端一岁小白-able.Feng, 无名之辈"><meta name="description" content="谁不是，拼了命走到生命的结尾"><title>无名之辈</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">无名之辈</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/23/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">作用域链和闭包</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-01-23</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>上个博客了解了如何通过词法环境和变量环境来查找变量，这其中就涉及到作用域链了，抽象的概念不如来段代码，来，上板栗🌰。</p>

        <h2 id="作用域链"   >
          <a href="#作用域链" class="heading-link"><i class="fas fa-link"></i></a>作用域链</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'zunxingdaming'</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  printName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'moriatry'</span>;</span><br><span class="line">main();</span><br></pre></td></tr></table></div></figure>
<p>那么main函数执行的结果是什么呢？当执行到printName函数内部时，name的值到底到底是从全局执行上下文还是main函数的执行上下文中取呢？可能容易按照调用栈的顺序来查找变量，执行到printName函数内部时，从栈顶到底依次为printName函数执行上下文、main函数执行上下文、全局执行上下文，如果是这样输出结果应该是able，但实际上不是这样，这是为甚呢，让我们进入作用域链的世界探究探究。<br>在每个执行上下文的变量环境里都有一个外部引用，指向外部的执行上下文，可称其为outer。一段代码中使用一个变量时，js引擎会先在当前执行上下文中查找该变量，然后会继续在outer指向的执行上下文中查找。printName函数和main函数的outer都是指向全局上下文，那么上面的栗子在printName函数中要输出name变量，则会取outer指向的全局作用域中寻找，这种查找方式即为链。<br>可能看到这里还会有一些疑问，printName函数是main函数调用的，为啥其outer不是指向main函数呢。这里涉及到一个概念词法作用域，在js的执行过程中，作用域链是由词法作用域来决定的。词法作用域呢表示作用域是由代码中函数声明的位置来决定的，所以说它是静态的，是在代码阶段就定下来了，跟函数是怎么互相调用的没有关系。</p>

        <h2 id="闭包"   >
          <a href="#闭包" class="heading-link"><i class="fas fa-link"></i></a>闭包</h2>
      <p>为了更好的理解闭包，再举个板栗🌰。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerFun = &#123;</span><br><span class="line">      getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;,</span><br><span class="line">setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  name = newName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funA = foo();</span><br><span class="line">funA.setName(<span class="string">'moriaty'</span>);</span><br><span class="line">funA.getName();</span><br><span class="line"><span class="built_in">console</span>.log(funA.getName());</span><br></pre></td></tr></table></div></figure>
<p>innerFun是一个对象，里边包含两个方法，这两个方法中用到了a变量和name变量。根据词法作用域，内部的函数可以访问外部函数foo中的变量。所以当innerFun返回给全局变量funA时，它的两个方法仍可以使用foo函数中的变量。<br>foo函数执行完后，其执行上下文从栈顶弹出，但是其返回的两个方法中使用了变量name和a，因此这两个变量仍保存在内存中。我们可以把它想象成setName和getName两个方法的背包，无法在哪里调用这两个方法，它们都会背着这个foo函数的背包，我们可以把这个背包称为foo函数的闭包。<br>此时此刻，上一个比较规范的闭包定义吧。在js中，根据词法作用域的规则，内部函数可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但内部函数引用外部函数但变量依然保存在内存中，我们称这些变量的集合称之为外部函数的闭包。<br>那么当执行到funA.setName方法中的name = ‘moriaty’时，js引擎会沿着“当前执行上下文-&gt;foo函数闭包-&gt;全局执行上下文”的顺序来查找name变量，可以看下此时的调用栈如下图。所以调用setName时，会修改闭包中name的值。<br><img src='/images/执行funA时调用栈.png' width='300px' height='500px'><br>关于闭包的销毁，如果引用闭包的函数是一个全局变量，那闭包会一直存在到页面关闭，但是如果这个闭包之后不实用的话，会造成内存泄漏。如果引用闭包的函数是个局部变量，等函数销毁后，下次js引擎执行垃圾回收时，判断闭包不再被使用，那么内存会被回收。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/26/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/">变量提升和块级作用域</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-12-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>开始接触JS的时候，想必大家都听过“变量提升”这个词。由于它的存在，一些代码的执行结果可能会出乎我们的意料，其实，这可以算是JS的一个设计缺陷吧。ES6引入了块级作用域和let、const关键字的概念，通过它们能够较好的规避变量提升。但是作为一门语言来说，向下兼容是必要的，所以变量提升的机制我们还是有必要去理解。今天我们尽量去深入底层来分析变量提升的存在原因，以及ES6又是如何去填补这块缺陷的。<br>首先我们需要了解作用域的概念，对于它的定义不同的参考资料都各有各的说法。一个我认为比较好理解的是：作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。它是变量和函数的可访问范围，控制着变量和函数的可见性和生命周期。<br>那么在ES6之前我们知道，只有全局作用域和函数作用域。全局作用域顾名思义就是在代码的任何地方都能访问到里边的对象，而函数作用域呢，就是指变量或者函数是在函数内部定义的，它只能在函数内部被访问。函数执行完后内部定义的变量会被销毁。<br>我们早期学过的C语言、C佳佳、Java等都是有块级作用域这么一个概念的，它是一对大括号包裹的一段代码，比如函数、if语句、for循环语句等。给一些简单等代码吧（全宇宙语言通用）</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">9</span>; i++; i&lt; <span class="number">10</span>) &#123; &#125;;</span><br></pre></td></tr></table></div></figure>
<p>代码块内定义的变量在代码块外部是无法被访问到的，而且上面有提到，代码块中的代码执行完毕后其定义的变量会被销毁。让我们梦回大一，看一段C语言的代码。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* name = <span class="string">"able"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printName();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于C语言有块级作用域，obviously上边的代码打印结果为全局变量的值able。但是如果这段代码是用JS写的呢，结果还会是一样么，我们接着往下看。<br>在ES6之前，Javascript是不支持块级作用域的。可能这门语言设计的初衷就是简约（而不简单），没有考虑块级作用域，所以作用域内部的变量都被统一提升了。导致函数中的变量无论在何处声明，编译时都会被进入到执行上下文的变量环境中，因此在整个函数体内所有地方都能被访问到。<br>我们来用JS来实现上面的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"able"</span>;</span><br><span class="line">printName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">printName();</span><br></pre></td></tr></table></div></figure>
<p>输出结果是什么呢，没想到吧，既不是”able”也不是”moriarty”，是undefined，这是为什么呢？根据之前文章所学，首先创建执行上下文和调用栈，其中printName函数执行上下文的变量环境中name为undefined。执行上下文创建好后，JS引擎执行函数内部代码。函数执行时JS会优先从当前的执行上下文中查找变量，首先执行console打印，那么它会使用函数上下文中的变量值undefined。相信很多人跟为一样，刚开始接触JS的时候会觉得这种结果有些奇怪吧。<br>还有一种情况就是本应被销毁的变量却没有销毁。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了解决变量提升，ES6引入了let和const关键字，使JS也拥有了块级作用域。let和const的用法大家都很清楚了，我们来看看ES6是如果解决变量提升的吧。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>
<p>可以看到输出结果就很符合我们的预期了，这是因为let关键字支持块级作用域，在作用域内声明的变量不会影响外面的变量。JS引擎通过变量环境来实现函数作用域，那么大家肯定会想，ES6即支持变量提升，又如何在函数作用域的基础上来支持块级作用域，它是如何做到的呢？接下来我们结合前面的博客执行上下文相关的知识来一起分析。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBlock</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line">setBlock();</span><br></pre></td></tr></table></div></figure>
<p>执行上面的代码时，首先编译并创建执行上下文，函数内部var声明的变量在编译阶段存放到了变量环境中，let声明的变量，存放到了词法环境中，但是如果是在函数的块级作用域内部let声明的变量并没有存放到词法环境中。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="setBlock函数执行上下文.png"><br>接下来执行代码，此时词法环境中n的值被设置成1。而当进入块级作用域时，作用域块中通过let声明当变量会被存放在词法环境一个单独的区域中，与作用域块外面的变量互不影响，也产生了一个小型栈结构。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C.png" alt="setBlock函数执行.png"><br>栈的底部是函数最外层的变量，进入块级作用域后块内let和const声明的变量会进栈，作用域执行完后该作用域的信息从顶部弹出。而console.log(m)时需要在词法环境和变量环境中来找变量a的值了。首先在词法环境的栈中从顶部向底部查找，如果在某个作用域块中找到了则直接返回，没有找到则继续在变量环境中查找。<br><img src="/images/%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" alt="变量查找过程.png"><br>通过以上我们可以了解到，块级作用域是通过词法环境的小型栈结构来实现的，而JS变量提升的特性是通过变量环境来实现的。想必通过今天的分析，大家对变量提升和块级作用域有了比较清晰的了解啦。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/11/14/JavaScript%E8%B0%83%E7%94%A8%E6%A0%88/">JavaScript调用栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-11-14</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在我们的日常开发中，相信大家应该会遇到过下边这种报错。从字面意思我们能理解为出现了栈溢出，栈占用的空间比分配给它的空间还大，常见的原因是两个函数之间的互相调用，还有就是没有终止条件的递归。栈大家都知道是一种数据结构，那么在这里的栈又是什么呢。那么我们今天来好好了解一下调用栈，概括来说它是用来管理函数调用关系的数据结构。<br>首先我们来说说函数调用，它是指我们声明一个函数并使它运行，具体的写法也就是一个函数名称后边加上一对圆括号。举个板栗</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></div></figure>
<p>在执行函数之前，我们用上一次的学习可以得知，这段代码会生成对应的全局执行上下文，其中的变量环境里包含了声明的函数sayHello和全局变量name、age。接下来开始执行全局代码，这里的sayHello便是一个函数调用，具体会有以下几个步骤。第一步是从全局执行的上下文中拿到声明的函数代码，然后是对这段函数对代码进行编译，创建函数对应的执行上下文和可执行代码，最后执行代码并输出结果。这里我们可以得知，在执行JS代码的时候可能会有多个执行上下文的存在，比如全局执行上下文和函数执行上下文，那么这里我们就能用栈这种数据结构，来管理这些执行上下文。<br>说到栈我们能想到最大的特点就是后进先出了，那么在执行上下文创建好以后，它们便会被压入到栈中，我们称之为调用栈，也叫执行上下文栈。为了更好理解它，我们来写一段比开头那段复杂些的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">by</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byTotal</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">  result = by(b, c);</span><br><span class="line">  <span class="keyword">return</span> a + result + d;</span><br><span class="line">&#125;</span><br><span class="line">byTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>he上边的情况是在一个函数中调用了另一个函数，我们来详细的分析一下过程。<br>首先创建全局上下文并入栈，当前生成的全局上下文的变量环境对象中有变量a、函数by和byTotal。当它入栈后，全局代码被执行，首先6被赋给a，此时调用栈中的情况如下图所示。<br><img src='/images/全局执行上下文.png' width='300px' height='500px'><br>然后是调用byTotal函数，调用时我们首先需要对其进行编译，也是为其创建一个函数执行上下文，并使其进入栈中，如下图所示。<br><img src='/images/byAll函数执行上下文.png' width='300px' height='500px'><br>执行上下文创建好后我们开始执行函数。首先对d进行赋值5，然后我们会执行到by函数，也会创建一个by函数的执行上下文，并使其入账，如下图所示。<br><img src='/images/by函数执行上下文.png' width='300px' height='500px'><br>那么什么时候开始出栈呢，便是by函数的执行结果返回后，它对应的函数执行上下文便会从栈顶弹出啦，此时byAll中的result得到了返回值3，如下图所示。<br><img src='images/函数执行上下文出栈.png' width='300px' height='500px'><br>然后在byAll执行完最后一行并返回值后，它对应的函数执行上下文也会出栈，此时的调用栈中重新回到了最初的亚子，只剩下一个孤零零的全局上下文了。<br>通过上边的步骤，我们可以了解到调用栈的作用了，它可以很直观的给我们展示某个函数在被执行，特别是函数调用较多时，能让我们很清楚各个函数之间的调用关系。<br>那么讲完了原理，它在实践层面上的应用我们一起来看看。在大家用chrome调试的时候，source中debug的位置有一个Call Stack不知道大家还有没有印象呢。我们在source中新建一个代码块(new snippet)，把上边那段demo放入js文件中，打上断点来执行一下这段代码。<br><img src="/images/chrome%E8%B0%83%E8%AF%95%E8%B0%83%E7%94%A8%E6%A0%88.png" alt="chrome调试调用栈.png"><br>我们在by函数中打上断点，右键点击run，可以看到图中的代码执行到断点处暂停了，右侧有Call Stack这一栏可以看到当前调用栈的情况，就跟我上图中画的一致，从底部到顶部依次是anonymous，也就是全局的函数入口，往上是byAll函数，最后顶部是by函数。我们能很直观明了的得知函数之间的调用关系。可能demo比较简单啊，但是在分析较为长的复杂的代码时，它是比较有效的，包括在定位问题时也是一样。如果不习惯打断点的童鞋，我们还有一种方式是使用一个方法——console.trace()，它的效果也是一样的，我们可以在控制台看到其结果。<br><img src="/images/console-trace.png" alt="console-trace.png"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/10/17/JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">JavaScript代码的执行顺序</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-10-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>今天我们来研究一下Javascript的执行顺序，了解它是怎么如何运行的。<br>首先我们来看一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行函数showName'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Javascript是按顺序执行的，那么看上去在执行到第一行的时候函数showName并没有定义，那么它是不是会报错呢。想必大家应该都知道,它的结果其实是执行函数showName;name undefined;<br>那么通过上边的执行结果，我们可以认识到，函数或者变量可以在它被定义之前使用。对于变量而言，如果它在执行过程中未声明，那么js执行会报错。如果在一个变量定义之前使用它，不会报错，但是该变量的值是undefined。如果在一个函数定义之前执行它，不会报错，而且函数能正常执行。<br>那可能就会产生一些疑问了，为啥子变量和函数能在定义之前使用呢，js不是想象中一行一行执行的么。都是提前使用，为何函数能正常执行，变量值却是undefined。我们来一步一步分析。<br>首先我们了解一下js中的声明和赋值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="comment">//这段代码可以分为两部分</span></span><br><span class="line"><span class="keyword">var</span> name  <span class="comment">//声明部分</span></span><br><span class="line">name = <span class="string">'able'</span>; <span class="comment">//执行部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hahhahaa'</span>);</span><br><span class="line">&#125;<span class="comment">//完整的函数声明，不涉及到赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> showName  <span class="comment">//声明部分</span></span><br><span class="line">showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125; <span class="comment">//赋值部分</span></span><br></pre></td></tr></table></div></figure>
<p>了解声明和赋值之后，，我们先来聊聊变量提升。<br>变量提升呢，它是指在Javascript代码的执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的‘行为’。变量被提升后，会给变量设置默认值‘undefined’。下面我们用代码来模拟一下变量提升。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量提升部分</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'showName被调用‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//可执行代码部分</span></span><br><span class="line"><span class="string">showName();</span></span><br><span class="line"><span class="string">console.log('</span>name<span class="string">', name);</span></span><br><span class="line"><span class="string">name = '</span>able<span class="string">';</span></span><br></pre></td></tr></table></div></figure>
<p>可以发现，它的执行结果和我们最开始的代码是一毛一样的。那么我们也就理解了为啥子可以在定义之前使用函数或者变量的原因了——函数和变量在执行之前都提升到了代码开头。<br>从字面上来看，变量提升意味着变量和函数的声明会移动到代码的开头，就像我们上边模拟的那样，但事实上，这可能不太准确，变量和函数声明在代码中的位置是不会被改变的，而是在编译阶段会被JS引擎放入到内存中。这里又涉及到JS的执行流程了，一段JS代码在执行之前需要被引擎编译，编译完成后才会进入执行阶段。<br>一段代码在经过编译后，会生成两部分内容：执行上下文和可执行代码。所谓执行上下文呢，它是指JS执行一段代码时的运行环境。比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的this、变量、对象以及函数等。在执行上下文中存在一个变量环境的对象，它里边保存了变量提升的内容，最开始我们研究的那段代码中，变量name和函数showName，都保存在该对象中。我们结合代码来分析一下如何生成变量环境对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'ableF'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'安排name‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>第一行第二行不是声明操作，所以引擎不会做任何处理。第三行有var声明，因此引擎将在环境对象中创建一个名为name的属性，并使用undefined对其初始化。第四行，引擎发现了一个通过function定义的函数，它将函数存储到堆中，并在环境变量中创建了一个showName的属性，然后将该属性值指向堆中函数的位置，这样就生成了变量环境对象。<br>我们可以用一张图来形象滴展示Js的执行流程。<br><img src="/images/Js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.jpg" alt="Js执行机制.jpg"><br>那么在有了执行上下文和可执行代码后，我们就可以进入执行阶段了。当执行showName函数时，JS引擎便在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JS引擎便开始执行该函数，并且输出‘执行函数showName‘的结果；接下来打印name信息，JS引擎在变量环境对象中查找该对象，由于变量环境中存在name变量且值为undefined，因此输出undefined。接下来把‘able’赋值给name变量，赋值后变量环境中的name属性值改为‘able’。<br>那么如果在代码中出现相同的变量或者函数会发生什么呢，我们来看下面一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">geName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'able'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'moriaty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></div></figure>
<p>我们来分析一下它的完整执行流程。首先是编译阶段，遇到了第一个getName函数，会把该函数放到变量环境中。接下来是第二个getName函数，继续存放到变量环境中，但是变量环境中已经有一个getName了，此时第二个会将第一个覆盖。那么可想而知，在执行阶段的时候，两个getName函数的执行都调用的是第二个函数。<br>总结<br>JavaScript的执行机制，先编译，再执行。在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。并且如果在编译阶段如果存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，因为它的逻辑是后定义的会覆盖先定义的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/22/%E6%89%8B%E5%86%99Promise/">手写Promise</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-08-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>说到异步编程，大家应该会想到Promise。想必对它对典型的认知应该就是——解决了回调地狱的问题，通过链式调用（不停的.then .then）的方式来避免大量嵌套。对于我个人而言，在使用Promise的过程中还是难免出现一些问题，感觉仍停留在稀里糊涂用的这么一个阶段。今天我想通过实现一个Promise来彻底搞懂其原理。<br>Promise我们可以称之为一个容器，它里边保存了一个异步操作的最终结果。这里有一个<span class="exturl"><a class="exturl__link"   href="https://promisesaplus.com/"  target="_blank" rel="noopener">Promises/A+规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>,我们可以按照其中的描述来一步一步的实现一个符合要求的Promise。<br>Promise有三个状态，等待、成功和失败，默认是等待状态。并且一旦成功或者失败了状态就不能改变了。<br>resolve接收一个函数作为参数，我们称之为excutor，它是一个执行器，会立即执行。它有两个参数resolve和reject，分别代表成功和失败。resolve代表的是成功，它会接收一个参数value，状态改变为fulfilled。reject代表的是失败，接收参数reason，状态改变为rejected。这里要注意的是，状态变为成功或者失败后不能再次被更改，如果new Promise的时候throw new Error报错也会变成失败态。<br>每个Promise应该有自己的三个状态，因此我们将它放在构造函数里。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'RESOLVED'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;<span class="comment">//默认是PENDING状态</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">this</span>.error = <span class="literal">undefined</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING)<span class="comment">//状态为PENDING时才能改变 &#123;</span></span><br><span class="line">        <span class="keyword">this</span>.status = RESOLVED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        <span class="comment">// 储存失败信息</span></span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);<span class="comment">//执行器执行时内部可能报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每个promise实例都有一个then方法，可以传入两个参数，onFulfilled和onRejected。如果当前状态成功我们调用onfFlfilled，失败调用onRejected.</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled,onRejected) &#123;</span><br><span class="line">   <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">     onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">     onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>当resolve在setTomeout里运行的时候，上边的写法就不能满足要求啦。我们可以采取发布订阅的思想，现将要执行的方法存到数组里，当状态改变后再执行对应的方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = RESOLVED;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">this</span>.error = reason;</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们需要判断then中传递函数的返回结果。当返回结果是promise时，则采用其状态。如果不是promise。将结果传递下去即可。Promise通过链式调用来解决回调地狱，也就是在第一个then里返回里一个Promise。我们可以在then里面返回一个新的promise,称为promise2。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="comment">// 当x为普通值时，通过resolve保存值。如果是promise则要调用then。我们可以通过一个公共方法来解析x的值和promise2的关系。这里要注意promise必须声明完后才能传入resolvePromise方法，我们可以用setTimeout宏任务做延迟，可以保证得到的是声明后的promise2</span></span><br><span class="line">    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure>

<p>接下来我们来实现resolvePromise这个方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//首先它的核心功能是判断x的值是不是resolve。而且它的写法要兼容所有的promise情况</span></span><br><span class="line">   <span class="comment">// 如果promise2和x链接的是同一个对象，则报错。比如let promise2 = p.then(() =&gt; &#123; return promise2 &#125;)</span></span><br><span class="line">   <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">     <span class="comment">// reject报错</span></span><br><span class="line">     <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用啦'</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 防止多次调用</span></span><br><span class="line">   <span class="keyword">let</span> called;</span><br><span class="line">   <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">       <span class="keyword">let</span> then = x.then;</span><br><span class="line">       <span class="comment">// 如果then是函数, 可以默认认为是promise了</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123; </span><br><span class="line">         <span class="comment">//y可能还是一个promise，直到解析出的结果是一个普通值</span></span><br><span class="line">         then.call(x, y =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">         &#125;, err =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           reject(err);<span class="comment">// 采用失败结果向下传递</span></span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         resolve(x); <span class="comment">// 说明x是普通对象，直接成功即可</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="comment">//防止多次调用成功和失败</span></span><br><span class="line">       <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">       called = <span class="literal">true</span>;</span><br><span class="line">       reject(e); </span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resolve(x);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>onFulfilled和onRejected均为可选参数。<br>onFulfilled返回一个普通的值，成功时直接等于 data =&gt; data<br>onRejected返回一个普通的值，失败时如果直接等于 data =&gt; data，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">data</span> =&gt;</span> data;</span><br><span class="line"><span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br></pre></td></tr></table></div></figure>

<p>实现了Promise，那么它的all方法和race方法相对来说就比较好实现了。<br>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>只有传入所有实例的状态都变成fulfilled，新的promises的状态才会变成fulfilled，此时每个实例的返回值组成一个数组，传递给promises的回调函数。<br>只要之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给整个promises的回调函数。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">      <span class="keyword">let</span> successCount = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>&#123;</span><br><span class="line">          arr[index] = data;</span><br><span class="line">          successCount++;</span><br><span class="line">          <span class="keyword">if</span> (successCount === promises.length) &#123;</span><br><span class="line">              resolve(arr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">          promises[i].then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">              processData(i, data)</span><br><span class="line">          &#125;, reject)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Promise.race也是将多个Promise实例包装成一个新的实例，只要有其中一个实例改变状态那么整个实例状态改变并停止执行。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/24/%E5%88%9D%E6%8E%A2hooks%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/">初探hooks实现与原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在使用hooks的过程中，大家可能会有一些疑惑。比如为什么useState只能在函数最外层调用，useEffect第二个参数的作用等。今天，我们来实现几个简单的hooks，并从中了解一些其原理。<br>1.useState<br>我们首先来实现useState。函数式组件没有实例，每次渲染都会重新执行useState函数。<br>我们声明一个lastState来保存上一次的状态。第一次渲染的时候执行useState，此时lastState没有值，将useState的参数作为初始值。在useState中定义一个setState的方法，来改变lastState的值。另外每次setState后要重新render。最终useState返回一个数组，里面包含上一个状态和改变状态的方法。以下为useState的简单实现。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastState;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">beginState</span>) </span>&#123;</span><br><span class="line">  lastState = lastState || beginState;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    lastState = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState, setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, setState] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>

<p>如果有多个state的时候，那么上面的写法就不适用了。lastState应该声明为一个数组，并且需要相对应有一个索引。要注意的是每次执行useState后需要让index加一，并且每次render后索引需要重置为0。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastState = [];</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">beginState</span>) </span>&#123;</span><br><span class="line">  lastState[index] = lastState[index]|| beginState;</span><br><span class="line">  <span class="keyword">const</span> currentIndex = index;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    lastState[currentIndex] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState[index++], setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, setState] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  index = 0;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>
<p>可以看出，每次渲染时state跟index是一一对应的，所以这也是不能把useState放到条件语句中的原因。所以在使用 Hook 的时候，我们应该在函数组件最外层使用。</p>
<p>2.useReducer<br>reducer接收两个参数，原有状态和动作，通过派发动作来改变状态，最后返回一个新状态。useReducer的实现和useState相似。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'add'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lastState;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, beginState</span>) </span>&#123;</span><br><span class="line">  lastState = lastState || beginState;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    lastState = reducer(lastState, action);</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, dispatch] = useReducer(reducer, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'add' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>

<p>3、useEffect<br>effect在这里是副作用的意思，我们可以在这个hooks中执行一些有副作用的行为，比如操作dom，通过ajax发送网络请求等。它里边的函数会在组件每次render后执行。而第二个参数我们称之为依赖项，如果其中的元素在每次渲染时和前一次相比没有发生变化，就不会触发这个副作用。下边的实现没有包括销毁副作用的功能。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastDependencies) &#123;</span><br><span class="line">    <span class="comment">//看看新的依赖数组是不是每一项都跟老的依赖数组中的每一项都相同</span></span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastDependencies[index];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      callback();</span><br><span class="line">      lastDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有渲染过</span></span><br><span class="line">    callback();</span><br><span class="line">    lastDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'看看数字是否变化了呢'</span>, number);</span><br><span class="line">  &#125;, [number]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setNumber(number + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>
<p>当依赖项为空的时候，我们会发现它只会执行一次，此时我们可以用useEffect来模拟componentDidMount生命周期。依赖项的比较是用的‘==’而不是‘===’，因此我们可以得知依赖项的对比是浅比较。<br>我们对于effect的实现比较简单，还有很多细节没有体现出来。在上面的代码中，每次执行useEffect都会打印最新的number值，那么它是如何读取到最新的state的呢。并不是number的值在“不变”的effect中发生了改变，而是每一次渲染中的effect的count值都来自于它属于的那次渲染。因为effect是在渲染完成后执行的，我们可以把它当作渲染结果的一部分。</p>
<p>4、useCallback和useMemo<br>在之前的文章中我们有了解过这两个性能优化的hooks。它们的实现和前面的hooks也很相似。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastCallback;</span><br><span class="line"><span class="keyword">let</span> lastCallbackDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastCallbackDependencies) &#123;</span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastCallbackDependencies[index];<span class="comment">//'=='表示浅比较</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      lastCallback = callback;</span><br><span class="line">      lastCallbackDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lastCallback = callback;</span><br><span class="line">    lastCallbackDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastCallback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lastMemo;</span><br><span class="line"><span class="keyword">let</span> lastMemoDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastMemoDependencies) &#123;</span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastMemoDependencies[index];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      lastMemo = callback();</span><br><span class="line">      lastMemoDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有渲染过</span></span><br><span class="line">    lastMemo = callback();</span><br><span class="line">    lastMemoDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastMemo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在本文中我们实现了一个最简单的hooks，主要借助的是数组这个简单的数据结构，一定成程度上了解了hooks的原理。但是在React的源码中，它是通过类似单链表的形式而不是数组。有空应该去读一读源码，才会有更深入的理解。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/25/useCallback%E3%80%81useMemo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">useCallback、useMemo的使用场景</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-25</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Hooks是React 16.8版本的新增特性，它的出现让我们可以不再写class组件来维护组件的内部状态。<br>在Hooks我们常用的基础方法为useState和useEffect，而对于useCallback和useMemo这两个方法，大家看到它的第一眼想到的可能就是性能优化吧。那么这两个方法是不是适用于所有的场景呢，这就是我们今天想要探讨的问题。</p>
<p>useMemo</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></div></figure>
<p>useMemo缓存计算结果，它接收一个计算的过程（回调函数，它将返回结果）和依赖项数据，返回一个memoized值。当依赖项发生变化的时候，回调函数会重新计算。</p>
<p>useCallback</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>
<p>useCallback缓存一个函数体，它接收回调参数和依赖项数组，返回一个 memoized 回调函数，只有依赖项发生变化的时候才会返回一个新的函数。</p>
<p>那么是不是所有场景下使用useCallback都能达到性能优化的效果呢。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState();</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">//等同于</span></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onChangeMemoized = useCallback(onChange, []);</span><br></pre></td></tr></table></div></figure>
<p>我们给一个input框传入onChange方法,当我们将它加上useCallback后，我们会发现这个方式除了定义了onChange方法外，还有调用useCallback产生了额外的开销，导致适得其反。<br>可能会有同学有疑问，我们不是用了useCallback吗，为啥onChange还会重新定义呢。这是因为函数组件每次state一变化，就重新执行，会重复声明。useCallback会缓存之前传入的回调函数，但是一旦依赖项发生变化，将返回新的函数。<br>实际上，useCallback在很多时候需要和React.memo搭配使用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> BigData = <span class="function">(<span class="params">&#123; showNum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="function"><span class="params">()</span> =&gt;</span> showNum());</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"子组件重新渲染了喔"</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNum(showNum());</span><br><span class="line">  &#125;, [showNum]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'BigData'</span>&gt;  </span><br><span class="line">      &#123;<span class="string">'child:'</span>+num&#125;</span><br><span class="line">      &lt;br&gt;&lt;<span class="regexp">/br&gt;</span></span><br><span class="line"><span class="regexp">      &#123;'假设子组件渲染大量数据...'&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(BigData) </span><br></pre></td></tr></table></div></figure>

<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">import</span> BigData <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> showNum = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> num; &#125;, [num]);</span><br><span class="line">  <span class="comment">// const showNum =() =&gt; &#123; return num; &#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'app'</span>&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">'parent:'</span> + num&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setNum(num * 2)&#125;&gt;*2&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;value&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125; /</span>&gt;</span><br><span class="line">      &lt;BigData showNum=&#123;showNum&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>我们假设一个场景，子组件需要展示大量的数据，它从父组件接收一个函数。在很多时候，父组件更新的时候，我们不需要子组件的更新。可能大家会给子组件包装到React.memo中（作用可参考shouldComponentUpdate(),但仅适用于函数组件）,来保证props相同的情况下不重复渲染组件。但是函数式组件更新的时候函数会重新声明，引用发生了变化。而React.memo函数只会浅比较props，因此子组件仍然会重新渲染。此时我们给要传入子组件的函数加上useCallback来保证函数引用的相等，从而达到子组件不重复渲染的效果，实现性能优化。<br>我们来看一下不加useCallback的时候<br><img src="/images/%E4%B8%8D%E4%BD%BF%E7%94%A8useCallback.png" alt="不使用useCallback.png"><br>可以看到state改变父组件重新渲染的时候，子组件也重新渲染了。</p>
<p>如果加上useCallback<br><img src="/images/%E4%BD%BF%E7%94%A8useCallback.png" alt="使用useCallback.png"><br>可以看到state改变父组件重新渲染的时候，子组件没有重新渲染，达到了我们想要的效果。</p>
<p>那么useMemo其实也是类似的，当我们需要给子组件传入一个引用类型的对象时，父组件重新渲染会导致值的引用发生变化。如果此时我们不需要重新渲染子组件时，可以用useMemo来记住这个值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    compute(num)</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"><span class="comment">//compute方法返回值为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">BigData</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>我们假设渲染子组件的开销较大（又是一个渲染大量数据的组件2333），那么value（返回值为引用类型）的引用变化而依赖项num没有变化时，我们可能不想子组件重新渲染。因此可以用useMemo来避免Example组件的渲染导致compute方法重新计算。此时value的引用不会发生变化，子组件不会重新渲染。<br>我们来看一个具体的例子</p>
<figure class="highlight jsx"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildMemo = <span class="function">(<span class="params">&#123; childData, onClick&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是子组件，我渲染了he'</span>)</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;span &gt;&#123;<span class="string">'子组件：'</span>+childData.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; onClick('变身2333')&#125;&gt;改变name&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default React.memo(ChildMemo);</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'子组件'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;span&gt;number:&#123;num&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;(e) =&gt; &#123; setNum(num + 1) &#125;&#125;&gt;加1&lt;/</span>button&gt;</span><br><span class="line">      &lt;ChildMemo</span><br><span class="line">        <span class="comment">// childData=&#123;</span></span><br><span class="line">        <span class="comment">//   &#123;</span></span><br><span class="line">        <span class="comment">//     name,</span></span><br><span class="line">        <span class="comment">//     color: name.indexOf('2333') !== -1 ? 'blue' : 'purple'</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        childData=&#123;</span><br><span class="line">          useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">            name,</span><br><span class="line">            color: name.indexOf(<span class="string">'2333'</span>) !== <span class="number">-1</span> ? <span class="string">'blue'</span> : <span class="string">'purple'</span></span><br><span class="line">          &#125;), [name])</span><br><span class="line">        &#125;</span><br><span class="line">        onClick=&#123;useCallback(<span class="function">(<span class="params">newName</span>) =&gt;</span> setName(newName), [])&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>当我们点击按钮时，如果childData返回值不加上useMemo,由于传入的参数为引用类型，引用变化会导致子组件的重新渲染。这种场景和上一个例子相似，只不过传入的参数不是一个方法，而是一个引用类型的值了。用useMemo可以保证在依赖项不变的时候，传入子组件的是同一个引用。</p>
<p>关于useMemo，还有一种情况我们可以使用。当一个函数的开销很大时（有较复杂的计算过程），我们可以用useMemo来记住它的返回值，这样可以避免性能消耗较高的重复计算。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> expensiveCompute(value), [value]);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">expensiveCompute</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...较复杂的计算过程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;result&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>加上useMemo后，虽然组件在重新渲染的时候将会重新定义这个开销较大的函数，但是它只会在被需要的时候才会被调用。当依赖项不变时，该方法将返回之前已经计算好的值。</p>
<p>总结<br>useCallback和useMemo的使用场景可以大致有以下两种。<br>1、保证传入子组件的引用相等<br>当子组件或者需要接收父组件传来的函数、对象、数组等引用类型时，或者它们被用在其他hook中的依赖数组中，我们应该使用。<br>2、开销大的运算<br>使用useMemo避免重复计算相同的结果。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/05/15/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E6%95%B0%E7%BB%84%E5%98%9B/">我真的了解数组嘛</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-05-15</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在日常的业务开发中，我们通常需要对后端返回的数据解构进行处理，得到我们想要的格式，而其中比较常见的场景便是对数组的操作。最开始用的时候只是看他人写法或者去菜鸟教程大致看一下demo，对于一些方法之间的区别、是否运用得合理没有明确的概念。还有一些方法（比如reduce）是之前有同学推荐过，但是一直没去用的，这次希望也能一网打尽。因此本次博客希望对数组相关的方法进行一个比较系统的总结，希望通过这次学习我能真正地了解数组，最好也不要再用一次“gugou”一次了QAQ。</p>

        <h4 id="1-some-和-find"   >
          <a href="#1-some-和-find" class="heading-link"><i class="fas fa-link"></i></a>1.some 和 find</h4>
      <p>当我们需要在数组中寻找一个元素时，我们通常会想到Array.find。它需要一个回调函数，并返回符合条件的第一个元素。然而，当我们仅仅需要知道数组中是否存在符合条件的元素时，Array.some或许是一个更好的办法，因为它返回的是一个布尔值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.find(callback, thisArg)</span><br></pre></td></tr></table></div></figure>
<p>callback 是数组每一项都会执行的回调函数，它接受三个参数：<br>value 当前正在被处理的项<br>index 当前项的索引<br>array 数组本身<br>thisArg 可选，用来当做fn函数内的this对象<br>说到find，在es6中它有一个兄弟Array.findIndex。它的入参和find基本一致，只不过它返回的是第一个符合条件的项在数组中的位置，如果没有符合条件的则返回-1。</p>

        <h4 id="2-find-和-filter"   >
          <a href="#2-find-和-filter" class="heading-link"><i class="fas fa-link"></i></a>2.find 和 filter</h4>
      <p>filter的中文意思是过滤，正如其名字所言，它的功能便是通过回调函数过滤数组，并将过滤后的项作为一个新数组返回。<br>看到上文中我们丢下find使用some的场景，find有些不服气。find曰：看看下面这个场景——我们需要通过一个唯一的ID 为过滤条件去过滤一个数组。如果此时用Array.filter的话，它将会遍历整个数组，当数组项很多时会多次执行回调函数。而明显本场景最终将只有一个符合条件的数据，我们用find在搜寻到第一个符合条件的结果后立即返回。从性能的角度上来说，让我们恭喜find！</p>

        <h4 id="3-indexOf-和-includes"   >
          <a href="#3-indexOf-和-includes" class="heading-link"><i class="fas fa-link"></i></a>3.indexOf 和 includes</h4>
      <p>Array.indexOf这个方法我们都狠熟悉了，它返回第一个指定元素的下标，如果不存在则返回-1。如果我们不需要知道下标，可以使用直接返回布尔值的 Array.includes。说到返回布尔值，你们有没有想起上面提到的some呢。注意了，注意了，一定要分清楚哦。Array.includes 的第一个入参是一个值， Array.some 的第一个入参是回调函数。includes简单，而some方法可以用来处理较为复杂的数组项哦。</p>

        <h4 id="4-reduce来咯"   >
          <a href="#4-reduce来咯" class="heading-link"><i class="fas fa-link"></i></a>4.reduce来咯</h4>
      <p>我们什么情况下可以使用reduce呢，有一个比较容易记的方法。当一个场景中我们需要先用Array.filter对数组进行过滤操作，然后对其进行遍历，用map方法返回一个新数组。此时我们可以用Array.reduce方法，一样的味道，更好的配方哦。Array.reduce方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></div></figure>
<p>callback 接受四个参数，分别是：accumulator，累加器累加回调的返回值； currentValue,数组中正在处理的元素；currentIndex（可选）,数组中正在处理的当前元素的索引；array（可选），调用 reduce() 的数组。initialValue 为可选参数，作为第一次调用 callback 函数时的第一个参数的值。方法的返回值是函数累计处理的结果。<br>PS：这里通过查阅资料还得知了mdn的语法，可选参数用括号+逗号 <code>[，</code>表示，而必需的参数只用逗号<code>,</code>。<br>光说不练假把式，让我们来进入实战！<br>emmm我们来模拟一个后端童鞋返回的数据。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'A'</span>,</span><br><span class="line">  number: <span class="number">6</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'B'</span>,</span><br><span class="line">  number: <span class="number">9</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: <span class="number">3</span>,</span><br><span class="line">  name: <span class="string">'C‘,</span></span><br><span class="line"><span class="string">  number: 2</span></span><br><span class="line"><span class="string">&#125;,...]</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-1"   >
          <a href="#Round-1" class="heading-link"><i class="fas fa-link"></i></a>Round 1</h5>
      <p>先从简单的开始，我们来统计number的总和吧。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">total, &#123; number &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + number;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-2"   >
          <a href="#Round-2" class="heading-link"><i class="fas fa-link"></i></a>Round 2</h5>
      <p> 加大难度，我们来将数组每项转换为字符串，项之间用空格隔开。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">str, &#123; id, name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str + <span class="string">`id:<span class="subst">$&#123;id&#125;</span>,type:<span class="subst">$&#123;name&#125;</span>+ `</span>;</span><br><span class="line">&#125;, <span class="string">''</span>)</span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-3"   >
          <a href="#Round-3" class="heading-link"><i class="fas fa-link"></i></a>Round 3</h5>
      <p> boss关，我们来将数组转换成 key value 的对象形式。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">obj, &#123; id, ...value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  obj[id] = &#123;</span><br><span class="line">    ...value,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></div></figure>
<p>最终返回的结果为</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'1'</span>: &#123; <span class="attr">name</span>: <span class="string">'A'</span>, <span class="attr">number</span>: <span class="number">6</span> &#125;,</span><br><span class="line">  <span class="string">'2'</span>: &#123; <span class="attr">name</span>: <span class="string">'B'</span>, <span class="attr">number</span>: <span class="number">9</span> &#125;,</span><br><span class="line">  <span class="string">'3'</span>: &#123; <span class="attr">name</span>: <span class="string">'C'</span>, <span class="attr">number</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>闯关成功，希望我们能学以致用，在今后的工作中很好滴运用这个方法😄</p>

        <h4 id="5-forEach-和-map"   >
          <a href="#5-forEach-和-map" class="heading-link"><i class="fas fa-link"></i></a>5.forEach 和 map</h4>
      <p>首先，我们可以明确的是，forEach()方法不会返回执行结果，而是undefined，而map()方法会得到一个新的数组并返回。forEach()允许callback更改原始数组的元素。map()返回新的数组。<br>项目中有很多地方直接在map方法的回调函数中修改原始数组的值，其实这样做是不建议的。这么做能行得通是因为js中的数组是引用类型，所以可以利用类似指针的特性通过改变另一个变量去修改原始的值。但是！但是！map方法体现的是数据不可变的思想。该思想认为所有的数据都是不能改变的，只能通过生成新的数据来达到修改的目的，因此直接对数组元素或对象属性进行操作的行为都是不可取的。这种思想其实有很多好处，最直接的就是避免了数据的隐式修改。我们来举个栗子。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    a:<span class="number">3</span>,</span><br><span class="line">    b:<span class="number">4</span>,</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//让我们来修改a的值为3</span></span><br><span class="line">arr = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;   <span class="comment">// 返回一个新的数组而不应该直接修改原数组</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        a:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>


        <h4 id="6-展望"   >
          <a href="#6-展望" class="heading-link"><i class="fas fa-link"></i></a>6.展望</h4>
      <p>emmm可能还有很多数组的方法没有照顾周全，如果以后还遇到一些问题和一些对数组巧妙操作的方法，我们再记录。还有性能上的问题，也值得我们去探讨。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/">React新版本生命周期及替换方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-04-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>React 16.3版本引入了两个新的生命周期函数，getDerivedStateFromProps，getSnapshotBeforeUpdate 。还有三个componentWillMount，componentWillReceiveProps，componentWillUpdate被标记为不安全的生命周期，将在17.0版本被移除。公司的项目逐渐要将不安全的生命周期移除，为以后版本升级React 17.0作准备。因此我们需要来对比一下新旧版本的生命周期，从而得出生命周期的替换方案。<br>在老版本的生命周期图谱中，被红框圈起来的三个生命周期函数就是在新版本中即将被移除的。<br><img src="/images/%E8%80%81%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="image.png(图中为React 老版本生命周期图谱)"><br>下图中为React 16.4版本的生命周期图谱。我们可以看到，React的生命周期仍分为三种类型。<br><img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%B0%B1.png" alt="image.png(图中为React 16.4版本生命周期图谱)"></p>
<ol>
<li>挂载时，挂载指的是组件实例被创建并插入DOM中。创建时有以下几个阶段，第一个为constructor，它是一个组件的构造函数，一个组件在更新到界面之前需要被创造出来。用于初始化内部状态，它是唯一直接修改state 的地方。第二个方法为getDerivedStateFromProps,它用于从外部的属性来初始化内部的状态，返回的状态可以更新到当前的状态上。第三个方法是render,是用来描述UI的dom结构。创建过程完成后会调用didmount方法，这时候所有的UI都渲染完成了，我们可以安全地操作dom节点以及调用接口来获取外部的资源。这个方法在整个生命周期中只执行一次。</li>
<li>更新时，它由组件的props或state发生变化时触发。更新时有以下几个阶段，第一个方法为getDerivedStateFromProps，第二个方法为shouldComponentUpdate， 它可以告诉组件我们是否需要render，可以用来性能优化。因为有时候我们在props变化时，界面UI并不需要变化，在方法中返回false告知不需要更新。返回true时react才会继续触发接下来的render。这个方法一般不需要自己去实现，react提供了purecomponent帮助我们判断props、state是否在前后有变化，如果没有变化它可以自己阻止react更新。pre-commit阶段调用getSnapshotBeforeUpdate,这个也是react 16.3新引入的方法。最后会有componentDidUpdate方法，这个方法每次UI发生更新时都会调用，react组件在外部属性或者内部状态变化时都会重新渲染，它始终会整体刷新，可以通过这个方法捕获每一次更新，从而判断是否需要其他操作。举一个我们项目中的栗子，审批的详情页，id通过url参数传入，用户切换到另一个审批，这个id发生变化，在方法中可以获取新的id对应的审批内容显示到界面上。</li>
<li>卸载时，组件从DOM中移除，通过willUnmount进行资源释放。</li>
</ol>
<p>新增的生命周期为 getDerivedStateFromProps和getSnapshotBeforeUpdate。</p>
<ol>
<li><p>getDerivedStateFromProps<br>它是react 16.3新引入的api，给我们提供了一个最佳实践——如何通过属性来初始化内部状态。它的使用场景是当state需要从props初始化来使用。这个方法的名字很长，据说是开发者们不推荐大家使用，因为如果state需要从props获得，一般都可以从props计算动态得到，不需要单独存储这个状态。因为如果一旦要单独存储，这意味着我们要始终维护两者的一致性，会增加很多的复杂度，容易出现bug。它每次更新时都会调用，这个api是用来取代componentwillreceiveprops方法。它的应用场景为我们的表单控件需要获取一个默认值，因为表单除了需要用户输入值之外，开始可能会给我们一个默认值。这个默认值一旦修改之后便没有有了。因此开始的state来源于外部的初始值，但当用户输入后state便来源于用户的输入。几乎在其他场景下我们不需要使用到这个生命周期方法。</p>
</li>
<li><p>getSnapshotBeforeUpdate<br>页面render之前会调用，它的典型场景为获取render之前的dom状态。此生命周期的任何返回值将作为参数传递给componentDidUpdate(prevProps, prevState, snapshot)。getSnapshotBeforeUpdate 的使用场景一般是获取组件更新之前的滚动条位置。</p>
</li>
</ol>
<p>接下来我结合项目来说明一下生命周期的替换方案。</p>
<ol>
<li><p>componentWillUpdate的替换<br>当组件收到新的props或state时，会在render之前调用 componentWillUpdate()。<br>componentWillUpdate(nextProps, nextState)<br>项目中有两处用到了componentWillUpdate方法，我们来看一段。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(&#123;changed, field&#125;, &#123;status&#125;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(status &amp;&amp; !<span class="keyword">this</span>.state.status || changed != <span class="keyword">this</span>.props.changed)&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;field&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这里在 componentWillUpdate 中根据 props 的变化去setState。但是 componentWillUpdate有可能在一次更新中被调用多次，在性能方面来说，多次setState在这里是不可取的。而componentDidUpdate一次更新中只会被调用一次，因此我们可以将 componentWillUpdate 中的内容迁移至 componentDidUpdate，改写后的代码如下</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!prevState.status &amp;&amp; <span class="keyword">this</span>.state.status) ||</span><br><span class="line">    prevProps.changed !== <span class="keyword">this</span>.props.changed</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="keyword">this</span>.props.field &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>componentWillReceiveProps的替换<br>componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, list &#125; = nextProps;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    data,</span><br><span class="line">    list,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从项目中找出一段代码，这里其实应该比较props有变化时再去setState，我们用getDerivedStateFromProps方法来替换<br>在React16.3中，我们可以这样来改写</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，16.4以后版本不能用这种写法， 会产生bug！！！</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== prevState.data || nextProps.list !== prevState.list) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: nextProps.data,</span><br><span class="line">      list: nextProps.list,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p><strong>请注意！！！</strong>在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发getDerivedStateFromProps，所以内部 state 变化后，又会走 getDerivedStateFromProps 方法，并把 state 值更新为传入的 prop。而且getDerivedStateFromProps 和 componentWillReceiveProps 只要父级重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”。因此，我们要改变一下判断条件，要注意把传入的 prop 值和之前传入的 prop 进行比较。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps (nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== prevState.prevPropData) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          data: nextProps.data,</span><br><span class="line">          prevPropData: nextProps.data,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>修改完了还有一点需要我们注意，由于componentWillReceiveProps在组件更新时才会调用，而getDerivedStateFromProps在初始挂载及后续更新时都会被调用，因此我们将生命周期替换后，如果didMount里有根据props初始化state的操作可以去掉，可以看到项目中有几处这样的地方。</p>
<p>  如果在componentWillReceiveProps中有执行副作用（例如数据获取）以响应 props 中的更改，我们可以改用在componentDidUpdate中触发这些回调。</p>
  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== <span class="keyword">this</span>.props.data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>  改为<br>  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.prevPropData !== <span class="keyword">this</span>.props.data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>
<p>  项目中也有很多地方，仅仅是在props更改时重置某些state，没有修改state的业务需求。我们可以从组件里删除state，把它变成一个受控组件。即使仍然有需求要保存临时的值，也可以由父组件像子组件传入一个方法手动执行保存这个动作。亦或者是将组件改为有key的非受控组件，因为当key变化时，React会创建一个新的而不是更新一个既有的组件。<br>      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo key=&#123;item.id&#125; defaultValue=&#123;item.value&#125;&gt;</span><br></pre></td></tr></table></div></figure><br>  每次id更改，都会重新创建组件，并将其状态重置为最新的value值。这个过程看起来很慢，不过这点性能是可以忽略的。而且如果在组件树的更新上有很重的逻辑，由于子组件的diff过程被省略了，这样反而会更快。</p>
<p>  <strong>总结</strong><br>  在使用getDerivedStateFromProps方法时，要注意把传入的 prop 值和之前传入的 prop 进行比较，其中之前传入的props通过return存储在state中。在用getDerivedStateFromProps之前可以想一想当前业务场景是否需要用到这个方法，同时保证它是纯函数，不要产生一些副作用。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/">高阶组件和函数作为子组件</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-03-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>React组件其中一个好处便是可以实现组件的重用。一个组件一旦定义好之后可以用在不同的UI场景之下。在日常的开发过程中，我们可以发现，组件的重用，不一定能满足所有的场景。今天，我来给大家介绍组件的两种复用形式：高阶组件和函数作为子组件。<br>1.高阶组件</p>
<p>高价组件是对现有组件的封装，形成一个新的组件。新的组件会有自己的应用逻辑，这些逻辑会产生一些新的状态，状态需要传给现有的组件。高阶组件没有自己的UI展现，而只是负责为它封装的组件提供额外的功能和数据。<br><img src="/images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" alt="高阶组件.png"></p>
<p>如上图，图中的三个圆圈代表三个组件，UI由组件树的方式来描述。当中间的蓝色组件需要一些属性时，他的父组件需要传递所有的属性给他，同样他也会把他的一些属性传给他的子组件。可以想到一个问题，如果一个组件的所有来自外部的属性都由他的父组件传递给他，那他的父组件需要知道这个组件的所有状态。如果相隔很多层节点，比如这个组件需要获取三层节点之上的节点的内部状态，则需要属性一层一层往下传，中间的两层完全不需要用到这个数据，它们接受属性的唯一目的只是为了把它往下传。我们便可以用高阶组件来解决这个问题。高阶组件可以自己去获取外部资源并对其做一定处理，然后把属性传递给封装前的组件。那么此时组件的数据便有了两个来源，一个是父组件传递给它的属性，另一个便是高阶组件传给它的一些属性。高阶组件产生一般是有个函数，这个函数接收一个组件作为参数，返回一个新的组件，我们把它叫做高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; HighOrderComponent(wrappedComponent)</span><br></pre></td></tr></table></div></figure>

<p>我们来看一个高阶组件的应用场景。<br>现在有一个在界面上显示当前时间的组件，每一秒变化一次。现在我们需要重用这个组件，比如有一个聊天框，我们需要在下面显示当前的时间。我们可以看一下clock组件中的代码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(this.timerID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick() &#123;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    date: new Date()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>它的主要逻辑就是实现一个计时器。在didmount生成一个定时器，在willunmount清除这个计时器，有一个tick方法用来更新当前时间的状态。如果我们要在一个聊天功能的页面中有一个显示时间功能，可以在这个页面加上定时器的逻辑来实现，还一种方法是把clock组件直接放入其中。如果把clock组件引入，有一个问题，clock组件决定了时间显示成啥样，但是如果我们的聊天页面需要显示另外一种时间格式，那么会有一些麻烦。比如聊天功能我们只是需要一个计时器来知道每秒的时候，如何展示是自己来决定，但是又不想重复实现这个逻辑。此时，便可以引入高阶组件的概念。用高阶组件来实现计时器的逻辑，然后把这个时间传递给聊天页面。<br>我们可以写一个计时器的代码，用来产生高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default function withTimer(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    state &#x3D; &#123; time: new Date() &#125;;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      clearInterval(this.timerID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tick() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        time: new Date()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent time&#x3D;&#123;this.state.time&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这个函数可以给已有的组件注入一个计时器的功能。它接收一个组件作为参数，并且返回一个组件作为返回值。可以看到它内部有正常的生命周期方法，但是它的render函数并没有自己任何新的东西，只是把传入的组件render，但是会增加一些其他的属性。比如这里增加的是time属性。<br>回到聊天页面，我们想要在其中加入计时器的功能，便可以引入这个withTimer，我们现在导出的是封装后的高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MessageList messages&#x3D;&#123;this.state.messages&#125; &#x2F;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input value&#x3D;&#123;this.state.inputMsg&#125; &#x2F;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;this.handleSend&#125;&gt;Send&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.time.toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withTimer(ChatApp);</span><br></pre></td></tr></table></div></figure>
<p>此时，原组件有了time的属性，我们把它在render方法中展示出来，显示一个当前时间的字符串。我们可以看到时间已经在聊天页面展示了，但是我们并不是重用了clock组件，而是写了一个高阶组件的函数，这个函数实现了一个定时器的逻辑，把时间通过props传入原组件。同样的，我们需要在另一个组件中实现不同格式的时间，也是很容易的，只需要把props传入的时间通过另一种格式展示出来就ok了。<br>以上便是高阶组件的一个应用场景实例，它可以帮你去实现一些通用的逻辑被不同组件使用，但是它自身并没有任何UI展现。</p>
<p>2.函数作为子组件<br>函数作为子组件是一个设计模式而不是react一个新的特性。看如下代码，定义了一个myComponent。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class myComponent extends React.Component &#123;</span><br><span class="line">  render( ) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;this.props.children(&#39;able Feng&#39;)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
<p>它是直接调用了children这个函数，说明它已经假设传入的children为一个函数。使用的时候需要在mycomponent的子元素中定义一个函数，这个函数接收一个参数返回一个节点。我们不是直接把一个节点作为children，而是把一个函数作为children。这并不是react的一个特性，而是因为mycomponent已经决定了自己是如何使用children，因此它是一个设计模式而不是一种特殊类型组件。<br>看如下例子，我们用函数作为子组件的方式来实现让外部告知你如何显示你选中的状态。我们选中一个颜色它直接展示颜色，选中小动物直接展示小动物的图片。<br><img src="/images/selector.png" alt="函数子组件.jpg"><br>定义一个advancedtabselector组件，它有一个children的属性，我们定义为一个function，即可执行的。除了tab的选中逻辑，现在加入了一个额外的内容区域，this.props.children由外部决定如何render选中的值，如果有value便调用这个children的函数。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;this.props.value&amp;&amp;this.props.children(this.props.value)&#125;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在使用这个组件时，我们可以定义一个函数作为这个advancedtabselector组件的children。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;AdvancedTabSelector</span><br><span class="line">         options&#x3D;&#123;colors&#125;</span><br><span class="line">         value&#x3D;&#123;this.state.color&#125;</span><br><span class="line">         onChange&#x3D;&#123;c &#x3D;&gt; this.setState(&#123; color: c &#125;)&#125;</span><br><span class="line">       &gt;</span><br><span class="line">         &#123;color &#x3D;&gt; (</span><br><span class="line">           &lt;span</span><br><span class="line">             style&#x3D;&#123;&#123;</span><br><span class="line">               display: &quot;inline-block&quot;,</span><br><span class="line">               backgroundColor: color,</span><br><span class="line">               width: &quot;40px&quot;,</span><br><span class="line">               height: &quot;40px&quot;</span><br><span class="line">             &#125;&#125;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line">         )&#125;</span><br><span class="line">       &lt;&#x2F;AdvancedTabSelector&gt;</span><br></pre></td></tr></table></div></figure>
<p>它的参数是当前颜色，我们来决定它如何显示颜色，例子中用span来展示颜色。同样的，如果选中是一个animal，定义一个函数接收animal作为参数，渲染出来一个图片。可以看到函数作为子组件有一个特点，一个组件如何render它的内容可以由使用者来决定，对于这个tabselector如何render选中的状态，可以由用tabselector的人来决定，而不是在组件内部不停增加自身功能来适配外部的使用场景，这样组件内部可以只有很小的scope，它的灵活性可以由函数作为子组件来决定。</p>
<p>3.总结：<br>组件复用的两种形式——高阶组件和函数作为子组件均为使用react的组件的新的方式，称为设计模式，而不是代表react有两种新类型的组件。在工作开发中我们可以结合业务场景去使用这两种设计模式。`</p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">谁不是，拼了命走到结尾，也许卑微，一生狼狈</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">11</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>前端一岁小白-able.Feng</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>