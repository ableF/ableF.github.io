<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:type" content="website">
<meta property="og:title" content="无名之辈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="无名之辈">
<meta property="og:description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="前端一岁小白-able.Feng">
<meta name="twitter:card" content="summary"><meta name="keywords" content="前端一岁小白-able.Feng, 无名之辈"><meta name="description" content="谁不是，拼了命走到生命的结尾"><title>无名之辈</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">无名之辈</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/10/17/JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">JavaScript代码的执行顺序</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-10-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>今天我们来研究一下Javascript的执行顺序，了解它是怎么如何运行的。<br>首先我们来看一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行函数showName'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Javascript是按顺序执行的，那么看上去在执行到第一行的时候函数showName并没有定义，那么它是不是会报错呢。想必大家应该都知道,它的结果其实是<img   src="https://upload-images.jianshu.io/upload_images/22533782-26b514282b093fef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" style=""  alt="image.png"><br>那么通过上边的执行结果，我们可以认识到，函数或者变量可以在它被定义之前使用。对于变量而言，如果它在执行过程中未声明，那么js执行会报错。如果在一个变量定义之前使用它，不会报错，但是该变量的值是undefined。如果在一个函数定义之前执行它，不会报错，而且函数能正常执行。<br>那可能就会产生一些疑问了，为啥子变量和函数能在定义之前使用呢，js不是想象中一行一行执行的么。都是提前使用，为何函数能正常执行，变量值却是undefined。我们来一步一步分析。<br>首先我们了解一下js中的声明和赋值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="comment">//这段代码可以分为两部分</span></span><br><span class="line"><span class="keyword">var</span> name  <span class="comment">//声明部分</span></span><br><span class="line">name = <span class="string">'able'</span>; <span class="comment">//执行部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hahhahaa'</span>);</span><br><span class="line">&#125;<span class="comment">//完整的函数声明，不涉及到赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> showName  <span class="comment">//声明部分</span></span><br><span class="line">showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125; <span class="comment">//赋值部分</span></span><br></pre></td></tr></table></div></figure>
<p>了解声明和赋值之后，，我们先来聊聊变量提升。<br>变量提升呢，它是指在Javascript代码的执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的‘行为’。变量被提升后，会给变量设置默认值‘undefined’。下面我们用代码来模拟一下变量提升。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量提升部分</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'showName被调用‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//可执行代码部分</span></span><br><span class="line"><span class="string">showName();</span></span><br><span class="line"><span class="string">console.log('</span>name<span class="string">', name);</span></span><br><span class="line"><span class="string">name = '</span>able<span class="string">';</span></span><br></pre></td></tr></table></div></figure>
<p>可以发现，它的执行结果和我们最开始的代码是一毛一样的。那么我们也就理解了为啥子可以在定义之前使用函数或者变量的原因了——函数和变量在执行之前都提升到了代码开头。<br>从字面上来看，变量提升意味着变量和函数的声明会移动到代码的开头，就像我们上边模拟的那样，但事实上，这可能不太准确，变量和函数声明在代码中的位置是不会被改变的，而是在编译阶段会被JS引擎放入到内存中。这里又涉及到JS的执行流程了，一段JS代码在执行之前需要被引擎编译，编译完成后才会进入执行阶段。<br>一段代码在经过编译后，会生成两部分内容：执行上下文和可执行代码。所谓执行上下文呢，它是指JS执行一段代码时的运行环境。比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的this、变量、对象以及函数等。在执行上下文中存在一个变量环境的对象，它里边保存了变量提升的内容，最开始我们研究的那段代码中，变量name和函数showName，都保存在该对象中。我们结合代码来分析一下如何生成变量环境对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'ableF'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'安排name‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>第一行第二行不是声明操作，所以引擎不会做任何处理。第三行有var声明，因此引擎将在环境对象中创建一个名为name的属性，并使用undefined对其初始化。第四行，引擎发现了一个通过function定义的函数，它将函数存储到堆中，并在环境变量中创建了一个showName的属性，然后将该属性值指向堆中函数的位置，这样就生成了变量环境对象。<br><img src="/images/Js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.png" alt="Js执行机制.png"><br>那么在有了执行上下文和可执行代码后，我们就可以进入执行阶段了。当执行showName函数时，JS引擎便在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JS引擎便开始执行该函数，并且输出‘执行函数showName‘的结果；接下来打印name信息，JS引擎在变量环境对象中查找该对象，由于变量环境中存在name变量且值为undefined，因此输出undefined。接下来把‘able’赋值给name变量，赋值后变量环境中的name属性值改为‘able’。<br>那么如果在代码中出现相同的变量或者函数会发生什么呢，我们来看下面一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">geName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'able'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'moriaty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></div></figure>
<p>我们来分析一下它的完整执行流程。首先是编译阶段，遇到了第一个getName函数，会把该函数放到变量环境中。接下来是第二个getName函数，继续存放到变量环境中，但是变量环境中已经有一个getName了，此时第二个会将第一个覆盖。那么可想而知，在执行阶段的时候，两个getName函数的执行都调用的是第二个函数。<br>总结<br>JavaScript的执行机制，先编译，再执行。在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。并且如果在编译阶段如果存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，因为它的逻辑是后定义的会覆盖先定义的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/22/%E6%89%8B%E5%86%99Promise/">手写Promise</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-08-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>说到异步编程，大家应该会想到Promise。想必对它对典型的认知应该就是——解决了回调地狱的问题，通过链式调用（不停的.then .then）的方式来避免大量嵌套。对于我个人而言，在使用Promise的过程中还是难免出现一些问题，感觉仍停留在稀里糊涂用的这么一个阶段。今天我想通过实现一个Promise来彻底搞懂其原理。<br>Promise我们可以称之为一个容器，它里边保存了一个异步操作的最终结果。这里有一个<span class="exturl"><a class="exturl__link"   href="https://promisesaplus.com/"  target="_blank" rel="noopener">Promises/A+规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>,我们可以按照其中的描述来一步一步的实现一个符合要求的Promise。<br>Promise有三个状态，等待、成功和失败，默认是等待状态。并且一旦成功或者失败了状态就不能改变了。<br>resolve接收一个函数作为参数，我们称之为excutor，它是一个执行器，会立即执行。它有两个参数resolve和reject，分别代表成功和失败。resolve代表的是成功，它会接收一个参数value，状态改变为fulfilled。reject代表的是失败，接收参数reason，状态改变为rejected。这里要注意的是，状态变为成功或者失败后不能再次被更改，如果new Promise的时候throw new Error报错也会变成失败态。<br>每个Promise应该有自己的三个状态，因此我们将它放在构造函数里。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'RESOLVED'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;<span class="comment">//默认是PENDING状态</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">this</span>.error = <span class="literal">undefined</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING)<span class="comment">//状态为PENDING时才能改变 &#123;</span></span><br><span class="line">        <span class="keyword">this</span>.status = RESOLVED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        <span class="comment">// 储存失败信息</span></span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);<span class="comment">//执行器执行时内部可能报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每个promise实例都有一个then方法，可以传入两个参数，onFulfilled和onRejected。如果当前状态成功我们调用onfFlfilled，失败调用onRejected.</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled,onRejected) &#123;</span><br><span class="line">   <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">     onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">     onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>当resolve在setTomeout里运行的时候，上边的写法就不能满足要求啦。我们可以采取发布订阅的思想，现将要执行的方法存到数组里，当状态改变后再执行对应的方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = RESOLVED;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">this</span>.error = reason;</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们需要判断then中传递函数的返回结果。当返回结果是promise时，则采用其状态。如果不是promise。将结果传递下去即可。Promise通过链式调用来解决回调地狱，也就是在第一个then里返回里一个Promise。我们可以在then里面返回一个新的promise,称为promise2。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="comment">// 当x为普通值时，通过resolve保存值。如果是promise则要调用then。我们可以通过一个公共方法来解析x的值和promise2的关系。这里要注意promise必须声明完后才能传入resolvePromise方法，我们可以用setTimeout宏任务做延迟，可以保证得到的是声明后的promise2</span></span><br><span class="line">    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure>

<p>接下来我们来实现resolvePromise这个方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//首先它的核心功能是判断x的值是不是resolve。而且它的写法要兼容所有的promise情况</span></span><br><span class="line">   <span class="comment">// 如果promise2和x链接的是同一个对象，则报错。比如let promise2 = p.then(() =&gt; &#123; return promise2 &#125;)</span></span><br><span class="line">   <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">     <span class="comment">// reject报错</span></span><br><span class="line">     <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用啦'</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 防止多次调用</span></span><br><span class="line">   <span class="keyword">let</span> called;</span><br><span class="line">   <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">       <span class="keyword">let</span> then = x.then;</span><br><span class="line">       <span class="comment">// 如果then是函数, 可以默认认为是promise了</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123; </span><br><span class="line">         <span class="comment">//y可能还是一个promise，直到解析出的结果是一个普通值</span></span><br><span class="line">         then.call(x, y =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">         &#125;, err =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           reject(err);<span class="comment">// 采用失败结果向下传递</span></span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         resolve(x); <span class="comment">// 说明x是普通对象，直接成功即可</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="comment">//防止多次调用成功和失败</span></span><br><span class="line">       <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">       called = <span class="literal">true</span>;</span><br><span class="line">       reject(e); </span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resolve(x);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>onFulfilled和onRejected均为可选参数。<br>onFulfilled返回一个普通的值，成功时直接等于 data =&gt; data<br>onRejected返回一个普通的值，失败时如果直接等于 data =&gt; data，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">data</span> =&gt;</span> data;</span><br><span class="line"><span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br></pre></td></tr></table></div></figure>

<p>实现了Promise，那么它的all方法和race方法相对来说就比较好实现了。<br>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>只有传入所有实例的状态都变成fulfilled，新的promises的状态才会变成fulfilled，此时每个实例的返回值组成一个数组，传递给promises的回调函数。<br>只要之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给整个promises的回调函数。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">      <span class="keyword">let</span> successCount = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>&#123;</span><br><span class="line">          arr[index] = data;</span><br><span class="line">          successCount++;</span><br><span class="line">          <span class="keyword">if</span> (successCount === promises.length) &#123;</span><br><span class="line">              resolve(arr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">          promises[i].then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">              processData(i, data)</span><br><span class="line">          &#125;, reject)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Promise.race也是将多个Promise实例包装成一个新的实例，只要有其中一个实例改变状态那么整个实例状态改变并停止执行。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/07/24/%E5%88%9D%E6%8E%A2hooks%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8E%9F%E7%90%86/">初探hooks实现与原理</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-07-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在使用hooks的过程中，大家可能会有一些疑惑。比如为什么useState只能在函数最外层调用，useEffect第二个参数的作用等。今天，我们来实现几个简单的hooks，并从中了解一些其原理。<br>1.useState<br>我们首先来实现useState。函数式组件没有实例，每次渲染都会重新执行useState函数。<br>我们声明一个lastState来保存上一次的状态。第一次渲染的时候执行useState，此时lastState没有值，将useState的参数作为初始值。在useState中定义一个setState的方法，来改变lastState的值。另外每次setState后要重新render。最终useState返回一个数组，里面包含上一个状态和改变状态的方法。以下为useState的简单实现。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastState;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">beginState</span>) </span>&#123;</span><br><span class="line">  lastState = lastState || beginState;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    lastState = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState, setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, setState] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>

<p>如果有多个state的时候，那么上面的写法就不适用了。lastState应该声明为一个数组，并且需要相对应有一个索引。要注意的是每次执行useState后需要让index加一，并且每次render后索引需要重置为0。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastState = [];</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">beginState</span>) </span>&#123;</span><br><span class="line">  lastState[index] = lastState[index]|| beginState;</span><br><span class="line">  <span class="keyword">const</span> currentIndex = index;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">setState</span>(<span class="params">newState</span>) </span>&#123;</span><br><span class="line">    lastState[currentIndex] = newState;</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState[index++], setState];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, setState] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setState(state + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  index = 0;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;App /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>
<p>可以看出，每次渲染时state跟index是一一对应的，所以这也是不能把useState放到条件语句中的原因。所以在使用 Hook 的时候，我们应该在函数组件最外层使用。</p>
<p>2.useReducer<br>reducer接收两个参数，原有状态和动作，通过派发动作来改变状态，最后返回一个新状态。useReducer的实现和useState相似。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reducer</span>(<span class="params">state, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (action.type === <span class="string">'add'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> state + <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lastState;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useReducer</span>(<span class="params">reducer, beginState</span>) </span>&#123;</span><br><span class="line">  lastState = lastState || beginState;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    lastState = reducer(lastState, action);</span><br><span class="line">    render();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> [lastState, dispatch];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [state, dispatch] = useReducer(reducer, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;state&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; dispatch(&#123; type: 'add' &#125;)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>

<p>3、useEffect<br>effect在这里是副作用的意思，我们可以在这个hooks中执行一些有副作用的行为，比如操作dom，通过ajax发送网络请求等。它里边的函数会在组件每次render后执行。而第二个参数我们称之为依赖项，如果其中的元素在每次渲染时和前一次相比没有发生变化，就不会触发这个副作用。下边的实现没有包括销毁副作用的功能。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useEffect</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastDependencies) &#123;</span><br><span class="line">    <span class="comment">//看看新的依赖数组是不是每一项都跟老的依赖数组中的每一项都相同</span></span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastDependencies[index];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      callback();</span><br><span class="line">      lastDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有渲染过</span></span><br><span class="line">    callback();</span><br><span class="line">    lastDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> [number, setNumber] = useState(<span class="number">0</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'看看数字是否变化了呢'</span>, number);</span><br><span class="line">  &#125;, [number]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;span&gt;&#123;number&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;() =&gt; setNumber(number + 1)&#125;&gt;+&lt;/</span>button&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">function render() &#123;</span></span><br><span class="line"><span class="regexp">  ReactDOM.render(</span></span><br><span class="line"><span class="regexp">    &lt;Counter /</span>&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">render();</span><br></pre></td></tr></table></div></figure>
<p>当依赖项为空的时候，我们会发现它只会执行一次，此时我们可以用useEffect来模拟componentDidMount生命周期。依赖项的比较是用的‘==’而不是‘===’，因此我们可以得知依赖项的对比是浅比较。<br>我们对于effect的实现比较简单，还有很多细节没有体现出来。在上面的代码中，每次执行useEffect都会打印最新的number值，那么它是如何读取到最新的state的呢。并不是number的值在“不变”的effect中发生了改变，而是每一次渲染中的effect的count值都来自于它属于的那次渲染。因为effect是在渲染完成后执行的，我们可以把它当作渲染结果的一部分。</p>
<p>4、useCallback和useMemo<br>在之前的文章中我们有了解过这两个性能优化的hooks。它们的实现和前面的hooks也很相似。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> lastCallback;</span><br><span class="line"><span class="keyword">let</span> lastCallbackDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useCallback</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastCallbackDependencies) &#123;</span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastCallbackDependencies[index];<span class="comment">//'=='表示浅比较</span></span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      lastCallback = callback;</span><br><span class="line">      lastCallbackDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lastCallback = callback;</span><br><span class="line">    lastCallbackDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastCallback;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> lastMemo;</span><br><span class="line"><span class="keyword">let</span> lastMemoDependencies;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useMemo</span>(<span class="params">callback, dependencies</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (lastMemoDependencies) &#123;</span><br><span class="line">    <span class="keyword">let</span> changed = !dependencies.every(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> item == lastMemoDependencies[index];</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">if</span> (changed) &#123;</span><br><span class="line">      lastMemo = callback();</span><br><span class="line">      lastMemoDependencies = dependencies;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;<span class="comment">//没有渲染过</span></span><br><span class="line">    lastMemo = callback();</span><br><span class="line">    lastMemoDependencies = dependencies;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> lastMemo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>在本文中我们实现了一个最简单的hooks，主要借助的是数组这个简单的数据结构，一定成程度上了解了hooks的原理。但是在React的源码中，它是通过类似单链表的形式而不是数组。有空应该去读一读源码，才会有更深入的理解。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/06/25/useCallback%E3%80%81useMemo%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF/">useCallback、useMemo的使用场景</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-06-25</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Hooks是React 16.8版本的新增特性，它的出现让我们可以不再写class组件来维护组件的内部状态。<br>在Hooks我们常用的基础方法为useState和useEffect，而对于useCallback和useMemo这两个方法，大家看到它的第一眼想到的可能就是性能优化吧。那么这两个方法是不是适用于所有的场景呢，这就是我们今天想要探讨的问题。</p>
<p>useMemo</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedValue = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> computeExpensiveValue(a, b), [a, b]);</span><br></pre></td></tr></table></div></figure>
<p>useMemo缓存计算结果，它接收一个计算的过程（回调函数，它将返回结果）和依赖项数据，返回一个memoized值。当依赖项发生变化的时候，回调函数会重新计算。</p>
<p>useCallback</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> memoizedCallback = useCallback(</span><br><span class="line">  () =&gt; &#123;</span><br><span class="line">    doSomething(a, b);</span><br><span class="line">  &#125;,</span><br><span class="line">  [a, b],</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>
<p>useCallback缓存一个函数体，它接收回调参数和依赖项数组，返回一个 memoized 回调函数，只有依赖项发生变化的时候才会返回一个新的函数。</p>
<p>那么是不是所有场景下使用useCallback都能达到性能优化的效果呢。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState();</span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">input</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> <span class="attr">onChange</span>=<span class="string">&#123;onChange&#125;</span> /&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">----------------------------------------------------------------------------------------------</span><br><span class="line">  <span class="keyword">const</span> onChange = useCallback(<span class="function"><span class="params">e</span>=&gt;</span> &#123;</span><br><span class="line">    setValue(e.target.value);</span><br><span class="line">  &#125;, []);</span><br><span class="line">  <span class="comment">//等同于</span></span><br><span class="line">  <span class="keyword">const</span> onChange = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      setValue(e.target.value);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">const</span> onChangeMemoized = useCallback(onChange, []);</span><br></pre></td></tr></table></div></figure>
<p>我们给一个input框传入onChange方法,当我们将它加上useCallback后，我们会发现这个方式除了定义了onChange方法外，还有调用useCallback产生了额外的开销，导致适得其反。<br>可能会有同学有疑问，我们不是用了useCallback吗，为啥onChange还会重新定义呢。这是因为函数组件每次state一变化，就重新执行，会重复声明。useCallback会缓存之前传入的回调函数，但是一旦依赖项发生变化，将返回新的函数。<br>实际上，useCallback在很多时候需要和React.memo搭配使用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> BigData = <span class="function">(<span class="params">&#123; showNum &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="function"><span class="params">()</span> =&gt;</span> showNum());</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"子组件重新渲染了喔"</span>);</span><br><span class="line">  useEffect(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    setNum(showNum());</span><br><span class="line">  &#125;, [showNum]);</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'BigData'</span>&gt;  </span><br><span class="line">      &#123;<span class="string">'child:'</span>+num&#125;</span><br><span class="line">      &lt;br&gt;&lt;<span class="regexp">/br&gt;</span></span><br><span class="line"><span class="regexp">      &#123;'假设子组件渲染大量数据...'&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> React.memo(BigData) </span><br></pre></td></tr></table></div></figure>

<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">import</span> BigData <span class="keyword">from</span> <span class="string">'./Child'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [value, setValue] = useState(<span class="string">''</span>);</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">const</span> showNum = useCallback(<span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="keyword">return</span> num; &#125;, [num]);</span><br><span class="line">  <span class="comment">// const showNum =() =&gt; &#123; return num; &#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">'app'</span>&gt;</span><br><span class="line">      &lt;div&gt;&#123;<span class="string">'parent:'</span> + num&#125;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;button onClick=&#123;() =&gt; setNum(num * 2)&#125;&gt;*2&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;input value=&#123;value&#125; onChange=&#123;event =&gt; setValue(event.target.value)&#125; /</span>&gt;</span><br><span class="line">      &lt;BigData showNum=&#123;showNum&#125; /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>我们假设一个场景，子组件需要展示大量的数据，它从父组件接收一个函数。在很多时候，父组件更新的时候，我们不需要子组件的更新。可能大家会给子组件包装到React.memo中（作用可参考shouldComponentUpdate(),但仅适用于函数组件）,来保证props相同的情况下不重复渲染组件。但是函数式组件更新的时候函数会重新声明，引用发生了变化。而React.memo函数只会浅比较props，因此子组件仍然会重新渲染。此时我们给要传入子组件的函数加上useCallback来保证函数引用的相等，从而达到子组件不重复渲染的效果，实现性能优化。<br>我们来看一下不加useCallback的时候<br><img src="/images/%E4%B8%8D%E4%BD%BF%E7%94%A8useCallback.png" alt="不使用useCallback.png"><br>可以看到state改变父组件重新渲染的时候，子组件也重新渲染了。</p>
<p>如果加上useCallback<br><img src="/images/%E4%BD%BF%E7%94%A8useCallback.png" alt="使用useCallback.png"><br>可以看到state改变父组件重新渲染的时候，子组件没有重新渲染，达到了我们想要的效果。</p>
<p>那么useMemo其实也是类似的，当我们需要给子组件传入一个引用类型的对象时，父组件重新渲染会导致值的引用发生变化。如果此时我们不需要重新渲染子组件时，可以用useMemo来记住这个值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> value = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    compute(num)</span><br><span class="line">  &#125;, [num]);</span><br><span class="line"><span class="comment">//compute方法返回值为数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">BigData</span> <span class="attr">value</span>=<span class="string">&#123;value&#125;</span> /&gt;</span></span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>
<p>我们假设渲染子组件的开销较大（又是一个渲染大量数据的组件2333），那么value（返回值为引用类型）的引用变化而依赖项num没有变化时，我们可能不想子组件重新渲染。因此可以用useMemo来避免Example组件的渲染导致compute方法重新计算。此时value的引用不会发生变化，子组件不会重新渲染。<br>我们来看一个具体的例子</p>
<figure class="highlight jsx"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子组件</span></span><br><span class="line"><span class="keyword">const</span> ChildMemo = <span class="function">(<span class="params">&#123; childData, onClick&#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'我是子组件，我渲染了he'</span>)</span><br><span class="line">  <span class="keyword">return</span>(</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">          &lt;span &gt;&#123;<span class="string">'子组件：'</span>+childData.name&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">          &lt;button onClick=&#123;() =&gt; onClick('变身2333')&#125;&gt;改变name&lt;/</span>button&gt;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp">export default React.memo(ChildMemo);</span></span><br></pre></td></tr></table></div></figure>

<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//父组件</span></span><br><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> [num, setNum] = useState(<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">const</span> [name, setName] = useState(<span class="string">'子组件'</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;span&gt;number:&#123;num&#125;&lt;<span class="regexp">/span&gt;</span></span><br><span class="line"><span class="regexp">      &lt;button onClick=&#123;(e) =&gt; &#123; setNum(num + 1) &#125;&#125;&gt;加1&lt;/</span>button&gt;</span><br><span class="line">      &lt;ChildMemo</span><br><span class="line">        <span class="comment">// childData=&#123;</span></span><br><span class="line">        <span class="comment">//   &#123;</span></span><br><span class="line">        <span class="comment">//     name,</span></span><br><span class="line">        <span class="comment">//     color: name.indexOf('2333') !== -1 ? 'blue' : 'purple'</span></span><br><span class="line">        <span class="comment">//   &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        childData=&#123;</span><br><span class="line">          useMemo(<span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">            name,</span><br><span class="line">            color: name.indexOf(<span class="string">'2333'</span>) !== <span class="number">-1</span> ? <span class="string">'blue'</span> : <span class="string">'purple'</span></span><br><span class="line">          &#125;), [name])</span><br><span class="line">        &#125;</span><br><span class="line">        onClick=&#123;useCallback(<span class="function">(<span class="params">newName</span>) =&gt;</span> setName(newName), [])&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>当我们点击按钮时，如果childData返回值不加上useMemo,由于传入的参数为引用类型，引用变化会导致子组件的重新渲染。这种场景和上一个例子相似，只不过传入的参数不是一个方法，而是一个引用类型的值了。用useMemo可以保证在依赖项不变的时候，传入子组件的是同一个引用。</p>
<p>关于useMemo，还有一种情况我们可以使用。当一个函数的开销很大时（有较复杂的计算过程），我们可以用useMemo来记住它的返回值，这样可以避免性能消耗较高的重复计算。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Example = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> result = useMemo(<span class="function"><span class="params">()</span> =&gt;</span> expensiveCompute(value), [value]);</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">expensiveCompute</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//...较复杂的计算过程</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;result&#125;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  )</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>加上useMemo后，虽然组件在重新渲染的时候将会重新定义这个开销较大的函数，但是它只会在被需要的时候才会被调用。当依赖项不变时，该方法将返回之前已经计算好的值。</p>
<p>总结<br>useCallback和useMemo的使用场景可以大致有以下两种。<br>1、保证传入子组件的引用相等<br>当子组件或者需要接收父组件传来的函数、对象、数组等引用类型时，或者它们被用在其他hook中的依赖数组中，我们应该使用。<br>2、开销大的运算<br>使用useMemo避免重复计算相同的结果。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/05/15/%E6%88%91%E7%9C%9F%E7%9A%84%E4%BA%86%E8%A7%A3%E6%95%B0%E7%BB%84%E5%98%9B/">我真的了解数组嘛</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-05-15</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在日常的业务开发中，我们通常需要对后端返回的数据解构进行处理，得到我们想要的格式，而其中比较常见的场景便是对数组的操作。最开始用的时候只是看他人写法或者去菜鸟教程大致看一下demo，对于一些方法之间的区别、是否运用得合理没有明确的概念。还有一些方法（比如reduce）是之前有同学推荐过，但是一直没去用的，这次希望也能一网打尽。因此本次博客希望对数组相关的方法进行一个比较系统的总结，希望通过这次学习我能真正地了解数组，最好也不要再用一次“gugou”一次了QAQ。</p>

        <h4 id="1-some-和-find"   >
          <a href="#1-some-和-find" class="heading-link"><i class="fas fa-link"></i></a>1.some 和 find</h4>
      <p>当我们需要在数组中寻找一个元素时，我们通常会想到Array.find。它需要一个回调函数，并返回符合条件的第一个元素。然而，当我们仅仅需要知道数组中是否存在符合条件的元素时，Array.some或许是一个更好的办法，因为它返回的是一个布尔值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.find(callback, thisArg)</span><br></pre></td></tr></table></div></figure>
<p>callback 是数组每一项都会执行的回调函数，它接受三个参数：<br>value 当前正在被处理的项<br>index 当前项的索引<br>array 数组本身<br>thisArg 可选，用来当做fn函数内的this对象<br>说到find，在es6中它有一个兄弟Array.findIndex。它的入参和find基本一致，只不过它返回的是第一个符合条件的项在数组中的位置，如果没有符合条件的则返回-1。</p>

        <h4 id="2-find-和-filter"   >
          <a href="#2-find-和-filter" class="heading-link"><i class="fas fa-link"></i></a>2.find 和 filter</h4>
      <p>filter的中文意思是过滤，正如其名字所言，它的功能便是通过回调函数过滤数组，并将过滤后的项作为一个新数组返回。<br>看到上文中我们丢下find使用some的场景，find有些不服气。find曰：看看下面这个场景——我们需要通过一个唯一的ID 为过滤条件去过滤一个数组。如果此时用Array.filter的话，它将会遍历整个数组，当数组项很多时会多次执行回调函数。而明显本场景最终将只有一个符合条件的数据，我们用find在搜寻到第一个符合条件的结果后立即返回。从性能的角度上来说，让我们恭喜find！</p>

        <h4 id="3-indexOf-和-includes"   >
          <a href="#3-indexOf-和-includes" class="heading-link"><i class="fas fa-link"></i></a>3.indexOf 和 includes</h4>
      <p>Array.indexOf这个方法我们都狠熟悉了，它返回第一个指定元素的下标，如果不存在则返回-1。如果我们不需要知道下标，可以使用直接返回布尔值的 Array.includes。说到返回布尔值，你们有没有想起上面提到的some呢。注意了，注意了，一定要分清楚哦。Array.includes 的第一个入参是一个值， Array.some 的第一个入参是回调函数。includes简单，而some方法可以用来处理较为复杂的数组项哦。</p>

        <h4 id="4-reduce来咯"   >
          <a href="#4-reduce来咯" class="heading-link"><i class="fas fa-link"></i></a>4.reduce来咯</h4>
      <p>我们什么情况下可以使用reduce呢，有一个比较容易记的方法。当一个场景中我们需要先用Array.filter对数组进行过滤操作，然后对其进行遍历，用map方法返回一个新数组。此时我们可以用Array.reduce方法，一样的味道，更好的配方哦。Array.reduce方法接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(callback(accumulator, currentValue[, index[, array]])[, initialValue])</span><br></pre></td></tr></table></div></figure>
<p>callback 接受四个参数，分别是：accumulator，累加器累加回调的返回值； currentValue,数组中正在处理的元素；currentIndex（可选）,数组中正在处理的当前元素的索引；array（可选），调用 reduce() 的数组。initialValue 为可选参数，作为第一次调用 callback 函数时的第一个参数的值。方法的返回值是函数累计处理的结果。<br>PS：这里通过查阅资料还得知了mdn的语法，可选参数用括号+逗号 <code>[，</code>表示，而必需的参数只用逗号<code>,</code>。<br>光说不练假把式，让我们来进入实战！<br>emmm我们来模拟一个后端童鞋返回的数据。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[&#123;</span><br><span class="line">  id: <span class="number">1</span>,</span><br><span class="line">  name: <span class="string">'A'</span>,</span><br><span class="line">  number: <span class="number">6</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: <span class="number">2</span>,</span><br><span class="line">  name: <span class="string">'B'</span>,</span><br><span class="line">  number: <span class="number">9</span></span><br><span class="line">&#125;, &#123;</span><br><span class="line">  id: <span class="number">3</span>,</span><br><span class="line">  name: <span class="string">'C‘,</span></span><br><span class="line"><span class="string">  number: 2</span></span><br><span class="line"><span class="string">&#125;,...]</span></span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-1"   >
          <a href="#Round-1" class="heading-link"><i class="fas fa-link"></i></a>Round 1</h5>
      <p>先从简单的开始，我们来统计number的总和吧。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">total, &#123; number &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> total + number;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-2"   >
          <a href="#Round-2" class="heading-link"><i class="fas fa-link"></i></a>Round 2</h5>
      <p> 加大难度，我们来将数组每项转换为字符串，项之间用空格隔开。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">str, &#123; id, name &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> str + <span class="string">`id:<span class="subst">$&#123;id&#125;</span>,type:<span class="subst">$&#123;name&#125;</span>+ `</span>;</span><br><span class="line">&#125;, <span class="string">''</span>)</span><br></pre></td></tr></table></div></figure>

        <h5 id="Round-3"   >
          <a href="#Round-3" class="heading-link"><i class="fas fa-link"></i></a>Round 3</h5>
      <p> boss关，我们来将数组转换成 key value 的对象形式。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">arr.reduce(<span class="function">(<span class="params">obj, &#123; id, ...value &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">  obj[id] = &#123;</span><br><span class="line">    ...value,</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;, &#123;&#125;)</span><br></pre></td></tr></table></div></figure>
<p>最终返回的结果为</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'1'</span>: &#123; <span class="attr">name</span>: <span class="string">'A'</span>, <span class="attr">number</span>: <span class="number">6</span> &#125;,</span><br><span class="line">  <span class="string">'2'</span>: &#123; <span class="attr">name</span>: <span class="string">'B'</span>, <span class="attr">number</span>: <span class="number">9</span> &#125;,</span><br><span class="line">  <span class="string">'3'</span>: &#123; <span class="attr">name</span>: <span class="string">'C'</span>, <span class="attr">number</span>: <span class="number">2</span> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>闯关成功，希望我们能学以致用，在今后的工作中很好滴运用这个方法😄</p>

        <h4 id="5-forEach-和-map"   >
          <a href="#5-forEach-和-map" class="heading-link"><i class="fas fa-link"></i></a>5.forEach 和 map</h4>
      <p>首先，我们可以明确的是，forEach()方法不会返回执行结果，而是undefined，而map()方法会得到一个新的数组并返回。forEach()允许callback更改原始数组的元素。map()返回新的数组。<br>项目中有很多地方直接在map方法的回调函数中修改原始数组的值，其实这样做是不建议的。这么做能行得通是因为js中的数组是引用类型，所以可以利用类似指针的特性通过改变另一个变量去修改原始的值。但是！但是！map方法体现的是数据不可变的思想。该思想认为所有的数据都是不能改变的，只能通过生成新的数据来达到修改的目的，因此直接对数组元素或对象属性进行操作的行为都是不可取的。这种思想其实有很多好处，最直接的就是避免了数据的隐式修改。我们来举个栗子。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [&#123;</span><br><span class="line">    a:<span class="number">1</span>,</span><br><span class="line">    b:<span class="number">2</span>,</span><br><span class="line">&#125;, &#123;</span><br><span class="line">    a:<span class="number">3</span>,</span><br><span class="line">    b:<span class="number">4</span>,</span><br><span class="line">&#125;];</span><br><span class="line"><span class="comment">//让我们来修改a的值为3</span></span><br><span class="line">arr = arr.map(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;   <span class="comment">// 返回一个新的数组而不应该直接修改原数组</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        ...item,</span><br><span class="line">        a:<span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></div></figure>


        <h4 id="6-展望"   >
          <a href="#6-展望" class="heading-link"><i class="fas fa-link"></i></a>6.展望</h4>
      <p>emmm可能还有很多数组的方法没有照顾周全，如果以后还遇到一些问题和一些对数组巧妙操作的方法，我们再记录。还有性能上的问题，也值得我们去探讨。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/">React新版本生命周期及替换方案</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-04-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>React 16.3版本引入了两个新的生命周期函数，getDerivedStateFromProps，getSnapshotBeforeUpdate 。还有三个componentWillMount，componentWillReceiveProps，componentWillUpdate被标记为不安全的生命周期，将在17.0版本被移除。公司的项目逐渐要将不安全的生命周期移除，为以后版本升级React 17.0作准备。因此我们需要来对比一下新旧版本的生命周期，从而得出生命周期的替换方案。<br>在老版本的生命周期图谱中，被红框圈起来的三个生命周期函数就是在新版本中即将被移除的。<br><img src="/images/%E8%80%81%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.jpg" alt="image.png(图中为React 老版本生命周期图谱)"><br>下图中为React 16.4版本的生命周期图谱。我们可以看到，React的生命周期仍分为三种类型。<br><img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%B0%B1.png" alt="image.png(图中为React 16.4版本生命周期图谱)"></p>
<ol>
<li>挂载时，挂载指的是组件实例被创建并插入DOM中。创建时有以下几个阶段，第一个为constructor，它是一个组件的构造函数，一个组件在更新到界面之前需要被创造出来。用于初始化内部状态，它是唯一直接修改state 的地方。第二个方法为getDerivedStateFromProps,它用于从外部的属性来初始化内部的状态，返回的状态可以更新到当前的状态上。第三个方法是render,是用来描述UI的dom结构。创建过程完成后会调用didmount方法，这时候所有的UI都渲染完成了，我们可以安全地操作dom节点以及调用接口来获取外部的资源。这个方法在整个生命周期中只执行一次。</li>
<li>更新时，它由组件的props或state发生变化时触发。更新时有以下几个阶段，第一个方法为getDerivedStateFromProps，第二个方法为shouldComponentUpdate， 它可以告诉组件我们是否需要render，可以用来性能优化。因为有时候我们在props变化时，界面UI并不需要变化，在方法中返回false告知不需要更新。返回true时react才会继续触发接下来的render。这个方法一般不需要自己去实现，react提供了purecomponent帮助我们判断props、state是否在前后有变化，如果没有变化它可以自己阻止react更新。pre-commit阶段调用getSnapshotBeforeUpdate,这个也是react 16.3新引入的方法。最后会有componentDidUpdate方法，这个方法每次UI发生更新时都会调用，react组件在外部属性或者内部状态变化时都会重新渲染，它始终会整体刷新，可以通过这个方法捕获每一次更新，从而判断是否需要其他操作。举一个我们项目中的栗子，审批的详情页，id通过url参数传入，用户切换到另一个审批，这个id发生变化，在方法中可以获取新的id对应的审批内容显示到界面上。</li>
<li>卸载时，组件从DOM中移除，通过willUnmount进行资源释放。</li>
</ol>
<p>新增的生命周期为 getDerivedStateFromProps和getSnapshotBeforeUpdate。</p>
<ol>
<li><p>getDerivedStateFromProps<br>它是react 16.3新引入的api，给我们提供了一个最佳实践——如何通过属性来初始化内部状态。它的使用场景是当state需要从props初始化来使用。这个方法的名字很长，据说是开发者们不推荐大家使用，因为如果state需要从props获得，一般都可以从props计算动态得到，不需要单独存储这个状态。因为如果一旦要单独存储，这意味着我们要始终维护两者的一致性，会增加很多的复杂度，容易出现bug。它每次更新时都会调用，这个api是用来取代componentwillreceiveprops方法。它的应用场景为我们的表单控件需要获取一个默认值，因为表单除了需要用户输入值之外，开始可能会给我们一个默认值。这个默认值一旦修改之后便没有有了。因此开始的state来源于外部的初始值，但当用户输入后state便来源于用户的输入。几乎在其他场景下我们不需要使用到这个生命周期方法。</p>
</li>
<li><p>getSnapshotBeforeUpdate<br>页面render之前会调用，它的典型场景为获取render之前的dom状态。此生命周期的任何返回值将作为参数传递给componentDidUpdate(prevProps, prevState, snapshot)。getSnapshotBeforeUpdate 的使用场景一般是获取组件更新之前的滚动条位置。</p>
</li>
</ol>
<p>接下来我结合项目来说明一下生命周期的替换方案。</p>
<ol>
<li><p>componentWillUpdate的替换<br>当组件收到新的props或state时，会在render之前调用 componentWillUpdate()。<br>componentWillUpdate(nextProps, nextState)<br>项目中有两处用到了componentWillUpdate方法，我们来看一段。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(&#123;changed, field&#125;, &#123;status&#125;)&#123;</span><br><span class="line">  <span class="keyword">if</span>(status &amp;&amp; !<span class="keyword">this</span>.state.status || changed != <span class="keyword">this</span>.props.changed)&#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;field&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这里在 componentWillUpdate 中根据 props 的变化去setState。但是 componentWillUpdate有可能在一次更新中被调用多次，在性能方面来说，多次setState在这里是不可取的。而componentDidUpdate一次更新中只会被调用一次，因此我们可以将 componentWillUpdate 中的内容迁移至 componentDidUpdate，改写后的代码如下</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    (!prevState.status &amp;&amp; <span class="keyword">this</span>.state.status) ||</span><br><span class="line">    prevProps.changed !== <span class="keyword">this</span>.props.changed</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="keyword">this</span>.props.field &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</li>
<li><p>componentWillReceiveProps的替换<br>componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> &#123; data, list &#125; = nextProps;</span><br><span class="line">  <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">    data,</span><br><span class="line">    list,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>从项目中找出一段代码，这里其实应该比较props有变化时再去setState，我们用getDerivedStateFromProps方法来替换<br>在React16.3中，我们可以这样来改写</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，16.4以后版本不能用这种写法， 会产生bug！！！</span></span><br><span class="line"><span class="keyword">static</span> getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== prevState.data || nextProps.list !== prevState.list) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      data: nextProps.data,</span><br><span class="line">      list: nextProps.list,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></li>
</ol>
<p><strong>请注意！！！</strong>在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发getDerivedStateFromProps，所以内部 state 变化后，又会走 getDerivedStateFromProps 方法，并把 state 值更新为传入的 prop。而且getDerivedStateFromProps 和 componentWillReceiveProps 只要父级重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”。因此，我们要改变一下判断条件，要注意把传入的 prop 值和之前传入的 prop 进行比较。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> getDerivedStateFromProps (nextProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== prevState.prevPropData) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">          data: nextProps.data,</span><br><span class="line">          prevPropData: nextProps.data,</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>修改完了还有一点需要我们注意，由于componentWillReceiveProps在组件更新时才会调用，而getDerivedStateFromProps在初始挂载及后续更新时都会被调用，因此我们将生命周期替换后，如果didMount里有根据props初始化state的操作可以去掉，可以看到项目中有几处这样的地方。</p>
<p>  如果在componentWillReceiveProps中有执行副作用（例如数据获取）以响应 props 中的更改，我们可以改用在componentDidUpdate中触发这些回调。</p>
  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  <span class="keyword">if</span> (nextProps.data !== <span class="keyword">this</span>.props.data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>  改为<br>  <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (prevState.prevPropData !== <span class="keyword">this</span>.props.data) &#123;</span><br><span class="line">    <span class="keyword">this</span>.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure></p>
<p>  项目中也有很多地方，仅仅是在props更改时重置某些state，没有修改state的业务需求。我们可以从组件里删除state，把它变成一个受控组件。即使仍然有需求要保存临时的值，也可以由父组件像子组件传入一个方法手动执行保存这个动作。亦或者是将组件改为有key的非受控组件，因为当key变化时，React会创建一个新的而不是更新一个既有的组件。<br>      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Demo key=&#123;item.id&#125; defaultValue=&#123;item.value&#125;&gt;</span><br></pre></td></tr></table></div></figure><br>  每次id更改，都会重新创建组件，并将其状态重置为最新的value值。这个过程看起来很慢，不过这点性能是可以忽略的。而且如果在组件树的更新上有很重的逻辑，由于子组件的diff过程被省略了，这样反而会更快。</p>
<p>  <strong>总结</strong><br>  在使用getDerivedStateFromProps方法时，要注意把传入的 prop 值和之前传入的 prop 进行比较，其中之前传入的props通过return存储在state中。在用getDerivedStateFromProps之前可以想一想当前业务场景是否需要用到这个方法，同时保证它是纯函数，不要产生一些副作用。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/">高阶组件和函数作为子组件</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-03-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>React组件其中一个好处便是可以实现组件的重用。一个组件一旦定义好之后可以用在不同的UI场景之下。在日常的开发过程中，我们可以发现，组件的重用，不一定能满足所有的场景。今天，我来给大家介绍组件的两种复用形式：高阶组件和函数作为子组件。<br>1.高阶组件</p>
<p>高价组件是对现有组件的封装，形成一个新的组件。新的组件会有自己的应用逻辑，这些逻辑会产生一些新的状态，状态需要传给现有的组件。高阶组件没有自己的UI展现，而只是负责为它封装的组件提供额外的功能和数据。<br><img src="/images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" alt="高阶组件.png"></p>
<p>如上图，图中的三个圆圈代表三个组件，UI由组件树的方式来描述。当中间的蓝色组件需要一些属性时，他的父组件需要传递所有的属性给他，同样他也会把他的一些属性传给他的子组件。可以想到一个问题，如果一个组件的所有来自外部的属性都由他的父组件传递给他，那他的父组件需要知道这个组件的所有状态。如果相隔很多层节点，比如这个组件需要获取三层节点之上的节点的内部状态，则需要属性一层一层往下传，中间的两层完全不需要用到这个数据，它们接受属性的唯一目的只是为了把它往下传。我们便可以用高阶组件来解决这个问题。高阶组件可以自己去获取外部资源并对其做一定处理，然后把属性传递给封装前的组件。那么此时组件的数据便有了两个来源，一个是父组件传递给它的属性，另一个便是高阶组件传给它的一些属性。高阶组件产生一般是有个函数，这个函数接收一个组件作为参数，返回一个新的组件，我们把它叫做高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; HighOrderComponent(wrappedComponent)</span><br></pre></td></tr></table></div></figure>

<p>我们来看一个高阶组件的应用场景。<br>现在有一个在界面上显示当前时间的组件，每一秒变化一次。现在我们需要重用这个组件，比如有一个聊天框，我们需要在下面显示当前的时间。我们可以看一下clock组件中的代码</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(this.timerID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick() &#123;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    date: new Date()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>它的主要逻辑就是实现一个计时器。在didmount生成一个定时器，在willunmount清除这个计时器，有一个tick方法用来更新当前时间的状态。如果我们要在一个聊天功能的页面中有一个显示时间功能，可以在这个页面加上定时器的逻辑来实现，还一种方法是把clock组件直接放入其中。如果把clock组件引入，有一个问题，clock组件决定了时间显示成啥样，但是如果我们的聊天页面需要显示另外一种时间格式，那么会有一些麻烦。比如聊天功能我们只是需要一个计时器来知道每秒的时候，如何展示是自己来决定，但是又不想重复实现这个逻辑。此时，便可以引入高阶组件的概念。用高阶组件来实现计时器的逻辑，然后把这个时间传递给聊天页面。<br>我们可以写一个计时器的代码，用来产生高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default function withTimer(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    state &#x3D; &#123; time: new Date() &#125;;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      clearInterval(this.timerID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tick() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        time: new Date()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent time&#x3D;&#123;this.state.time&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>这个函数可以给已有的组件注入一个计时器的功能。它接收一个组件作为参数，并且返回一个组件作为返回值。可以看到它内部有正常的生命周期方法，但是它的render函数并没有自己任何新的东西，只是把传入的组件render，但是会增加一些其他的属性。比如这里增加的是time属性。<br>回到聊天页面，我们想要在其中加入计时器的功能，便可以引入这个withTimer，我们现在导出的是封装后的高阶组件。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MessageList messages&#x3D;&#123;this.state.messages&#125; &#x2F;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input value&#x3D;&#123;this.state.inputMsg&#125; &#x2F;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;this.handleSend&#125;&gt;Send&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.time.toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withTimer(ChatApp);</span><br></pre></td></tr></table></div></figure>
<p>此时，原组件有了time的属性，我们把它在render方法中展示出来，显示一个当前时间的字符串。我们可以看到时间已经在聊天页面展示了，但是我们并不是重用了clock组件，而是写了一个高阶组件的函数，这个函数实现了一个定时器的逻辑，把时间通过props传入原组件。同样的，我们需要在另一个组件中实现不同格式的时间，也是很容易的，只需要把props传入的时间通过另一种格式展示出来就ok了。<br>以上便是高阶组件的一个应用场景实例，它可以帮你去实现一些通用的逻辑被不同组件使用，但是它自身并没有任何UI展现。</p>
<p>2.函数作为子组件<br>函数作为子组件是一个设计模式而不是react一个新的特性。看如下代码，定义了一个myComponent。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class myComponent extends React.Component &#123;</span><br><span class="line">  render( ) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;this.props.children(&#39;able Feng&#39;)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></div></figure>
<p>它是直接调用了children这个函数，说明它已经假设传入的children为一个函数。使用的时候需要在mycomponent的子元素中定义一个函数，这个函数接收一个参数返回一个节点。我们不是直接把一个节点作为children，而是把一个函数作为children。这并不是react的一个特性，而是因为mycomponent已经决定了自己是如何使用children，因此它是一个设计模式而不是一种特殊类型组件。<br>看如下例子，我们用函数作为子组件的方式来实现让外部告知你如何显示你选中的状态。我们选中一个颜色它直接展示颜色，选中小动物直接展示小动物的图片。<br><img src="/images/selector.png" alt="函数子组件.jpg"><br>定义一个advancedtabselector组件，它有一个children的属性，我们定义为一个function，即可执行的。除了tab的选中逻辑，现在加入了一个额外的内容区域，this.props.children由外部决定如何render选中的值，如果有value便调用这个children的函数。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;this.props.value&amp;&amp;this.props.children(this.props.value)&#125;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>在使用这个组件时，我们可以定义一个函数作为这个advancedtabselector组件的children。</p>
<figure class="highlight plain"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;AdvancedTabSelector</span><br><span class="line">         options&#x3D;&#123;colors&#125;</span><br><span class="line">         value&#x3D;&#123;this.state.color&#125;</span><br><span class="line">         onChange&#x3D;&#123;c &#x3D;&gt; this.setState(&#123; color: c &#125;)&#125;</span><br><span class="line">       &gt;</span><br><span class="line">         &#123;color &#x3D;&gt; (</span><br><span class="line">           &lt;span</span><br><span class="line">             style&#x3D;&#123;&#123;</span><br><span class="line">               display: &quot;inline-block&quot;,</span><br><span class="line">               backgroundColor: color,</span><br><span class="line">               width: &quot;40px&quot;,</span><br><span class="line">               height: &quot;40px&quot;</span><br><span class="line">             &#125;&#125;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line">         )&#125;</span><br><span class="line">       &lt;&#x2F;AdvancedTabSelector&gt;</span><br></pre></td></tr></table></div></figure>
<p>它的参数是当前颜色，我们来决定它如何显示颜色，例子中用span来展示颜色。同样的，如果选中是一个animal，定义一个函数接收animal作为参数，渲染出来一个图片。可以看到函数作为子组件有一个特点，一个组件如何render它的内容可以由使用者来决定，对于这个tabselector如何render选中的状态，可以由用tabselector的人来决定，而不是在组件内部不停增加自身功能来适配外部的使用场景，这样组件内部可以只有很小的scope，它的灵活性可以由函数作为子组件来决定。</p>
<p>3.总结：<br>组件复用的两种形式——高阶组件和函数作为子组件均为使用react的组件的新的方式，称为设计模式，而不是代表react有两种新类型的组件。在工作开发中我们可以结合业务场景去使用这两种设计模式。`</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/03/17/hello-world/">Hello World</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-03-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Welcome to <span class="exturl"><a class="exturl__link"   href="https://hexo.io/"  target="_blank" rel="noopener">Hexo</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>! This is your very first post. Check <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/"  target="_blank" rel="noopener">documentation</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> for more info. If you get any problems when using Hexo, you can find the answer in <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/troubleshooting.html"  target="_blank" rel="noopener">troubleshooting</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span> or you can ask me on <span class="exturl"><a class="exturl__link"   href="https://github.com/hexojs/hexo/issues"  target="_blank" rel="noopener">GitHub</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>.</p>

        <h2 id="Quick-Start"   >
          <a href="#Quick-Start" class="heading-link"><i class="fas fa-link"></i></a>Quick Start</h2>
      
        <h3 id="Create-a-new-post"   >
          <a href="#Create-a-new-post" class="heading-link"><i class="fas fa-link"></i></a>Create a new post</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/writing.html"  target="_blank" rel="noopener">Writing</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Run-server"   >
          <a href="#Run-server" class="heading-link"><i class="fas fa-link"></i></a>Run server</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/server.html"  target="_blank" rel="noopener">Server</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Generate-static-files"   >
          <a href="#Generate-static-files" class="heading-link"><i class="fas fa-link"></i></a>Generate static files</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/generating.html"  target="_blank" rel="noopener">Generating</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>

        <h3 id="Deploy-to-remote-sites"   >
          <a href="#Deploy-to-remote-sites" class="heading-link"><i class="fas fa-link"></i></a>Deploy to remote sites</h3>
      <figure class="highlight bash"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></div></figure>

<p>More info: <span class="exturl"><a class="exturl__link"   href="https://hexo.io/docs/one-command-deployment.html"  target="_blank" rel="noopener">Deployment</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">谁不是，拼了命走到结尾，也许卑微，一生狼狈</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">8</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2020</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>前端一岁小白-able.Feng</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>