<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-React新版本生命周期及替换方案" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2020-04-24T08:44:00.954Z" itemprop="datePublished">2020-04-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/">React新版本生命周期及替换方案</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>#React新版本生命周期及替换方案</p>
<p>React 16.3版本引入了两个新的生命周期函数，getDerivedStateFromProps，getSnapshotBeforeUpdate 。还有三个componentWillMount，componentWillReceiveProps，componentWillUpdate被标记为不安全的生命周期，将在17.0版本被移除。公司的项目逐渐要将不安全的生命周期移除，为以后版本升级React 17.0作准备。因此我们需要来对比一下新旧版本的生命周期，从而得出生命周期的替换方案。<br>图中为React 16.4版本的生命周期图谱。我们可以看到，React的生命周期仍分为三种类型。<br><img src="/images/%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%9B%BE%E8%B0%B1.png" alt="image.png(图中为React 16.4版本生命周期图谱)"><br>1、挂载时，挂载指的是组件实例被创建并插入DOM中。创建时有以下几个阶段，第一个为constructor，它是一个组件的构造函数，一个组件在更新到界面之前需要被创造出来。用于初始化内部状态，它是唯一直接修改state 的地方。第二个方法为getDerivedStateFromProps,它用于从外部的属性来初始化内部的状态，返回的状态可以更新到当前的状态上。第三个方法是render,是用来描述UI的dom结构。创建过程完成后会调用didmount方法，这时候所有的UI都渲染完成了，我们可以安全地操作dom节点以及调用接口来获取外部的资源。这个方法在整个生命周期中只执行一次。<br>2、更新时，它由组件的props或state发生变化时触发。更新时有以下几个阶段，第一个方法为getDerivedStateFromProps，第二个方法为shouldComponentUpdate， 它可以告诉组件我们是否需要render，可以用来性能优化。因为有时候我们在props变化时，界面UI并不需要变化，在方法中返回false告知不需要更新。返回true时react才会继续触发接下来的render。这个方法一般不需要自己去实现，react提供了purecomponent帮助我们判断props、state是否在前后有变化，如果没有变化它可以自己阻止react更新。pre-commit阶段调用getSnapshotBeforeUpdate,这个也是react 16.3新引入的方法。最后会有componentDidUpdate方法，这个方法每次UI发生更新时都会调用，react组件在外部属性或者内部状态变化时都会重新渲染，它始终会整体刷新，可以通过这个方法捕获每一次更新，从而判断是否需要其他操作。举一个我们项目中的栗子，审批的详情页，id通过url参数传入，用户切换到另一个审批，这个id发生变化，在方法中可以获取新的id对应的审批内容显示到界面上。<br>3、卸载时，组件从DOM中移除，通过willUnmount进行资源释放。</p>
<p>新增的生命周期为 getDerivedStateFromProps和getSnapshotBeforeUpdate。</p>
<ol>
<li>getDerivedStateFromProps<br>它是react 16.3新引入的api，给我们提供了一个最佳实践——如何通过属性来初始化内部状态。它的使用场景是当state需要从props初始化来使用。这个方法的名字很长，据说是开发者们不推荐大家使用，因为如果state需要从props获得，一般都可以从props计算动态得到，不需要单独存储这个状态。因为如果一旦要单独存储，这意味着我们要始终维护两者的一致性，会增加很多的复杂度，容易出现bug。它每次更新时都会调用，这个api是用来取代componentwillreceiveprops方法。它的应用场景为我们的表单控件需要获取一个默认值，因为表单除了需要用户输入值之外，开始可能会给我们一个默认值。这个默认值一旦修改之后便没有有了。因此开始的state来源于外部的初始值，但当用户输入后state便来源于用户的输入。几乎在其他场景下我们不需要使用到这个生命周期方法。</li>
<li>getSnapshotBeforeUpdate<br>页面render之前会调用，它的典型场景为获取render之前的dom状态。</li>
</ol>
<p>接下来我结合项目来说明一下生命周期的替换方案。<br>当组件收到新的props或state时，会在render之前调用 componentWillUpdate()。<br>componentWillUpdate(nextProps, nextState)<br>项目中有两处用到了componentWillUpdate方法，我们来看一段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillUpdate(&#123;changed, field&#125;, &#123;status&#125;)&#123;</span><br><span class="line">		if(status &amp;&amp; !this.state.status || changed !&#x3D; this.props.changed)&#123;</span><br><span class="line">			this.setState(&#123;field&#125;);</span><br><span class="line">		&#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这里在 componentWillUpdate 中根据 props 的变化去setState。但是 componentWillUpdate有可能在一次更新中被调用多次，在性能方面来说，多次setState在这里是不可取的。而componentDidUpdate一次更新中只会被调用一次，因此我们可以将 componentWillUpdate 中的内容迁移至 componentDidUpdate，改写后的代码如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    if (</span><br><span class="line">      (!prevState.status &amp;&amp; this.state.status) ||</span><br><span class="line">      prevProps.changed !&#x3D;&#x3D; this.props.changed</span><br><span class="line">    ) &#123;</span><br><span class="line">      this.setState(&#123; this.props.field &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>componentWillReceiveProps() 会在已挂载的组件接收新的 props 之前被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">    const &#123; data, list &#125; &#x3D; nextProps;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      data,</span><br><span class="line">      list,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从项目中找出一段代码，这里其实应该比较props有变化时再去setState，我们用getDerivedStateFromProps方法来替换<br>在React16.3中，我们可以这样来改写</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;注意，16.4以后版本不能用这种写法， 会产生bug！！！</span><br><span class="line">static getDerivedStateFromProps(nextProps, prevState) &#123;</span><br><span class="line">    if (nextProps.data !&#x3D;&#x3D; prevState.data || nextProps.list !&#x3D;&#x3D; prevState.list) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        data: nextProps.data,</span><br><span class="line">        list: nextProps.list,</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    return null;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>请注意！！！在 React 16.4^ 的版本中 setState 和 forceUpdate 也会触发getDerivedStateFromProps，所以内部 state 变化后，又会走 getDerivedStateFromProps 方法，并把 state 值更新为传入的 prop。而且getDerivedStateFromProps 和 componentWillReceiveProps 只要父级重新渲染时，这两个生命周期函数就会重新调用，不管 props 有没有“变化”。因此，我们要改变一下判断条件，要注意把传入的 prop 值和之前传入的 prop 进行比较。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static getDerivedStateFromProps (nextProps, prevState) &#123;</span><br><span class="line">       if (nextProps.data !&#x3D;&#x3D; prevState.prevPropData) &#123;</span><br><span class="line">           return &#123;</span><br><span class="line">               data: nextProps.data,</span><br><span class="line">               prevPropData: nextProps.data,</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>componentWillReceiveProps在组件更新时才会调用，而getDerivedStateFromProps在初始挂载及后续更新时都会被调用，因此我们将生命周期替换后，如果didMount里有根据props初始化state的操作可以去掉。</p>
<p>如果在componentWillReceiveProps中有执行副作用（例如数据获取）以响应 props 中的更改，我们可以改用在componentDidUpdate中触发这些回调。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">  if (nextProps.data !&#x3D;&#x3D; this.props.data) &#123;</span><br><span class="line">        this.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>改为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">  if (prevState.prevPropData !&#x3D;&#x3D; this.props.data) &#123;</span><br><span class="line">    this.getData(data.type);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/" data-id="ck9dy9fhs0000nn5x0w274g4j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-高阶组件和函数作为子组件" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/" class="article-date">
  <time datetime="2020-03-17T09:06:48.687Z" itemprop="datePublished">2020-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/">高阶组件和函数作为子组件</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>React组件其中一个好处便是可以实现组件的重用。一个组件一旦定义好之后可以用在不同的UI场景之下。在日常的开发过程中，我们可以发现，组件的重用，不一定能满足所有的场景。今天，我来给大家介绍组件的两种复用形式：高阶组件和函数作为子组件。<br>1.高阶组件</p>
<p>高价组件是对现有组件的封装，形成一个新的组件。新的组件会有自己的应用逻辑，这些逻辑会产生一些新的状态，状态需要传给现有的组件。高阶组件没有自己的UI展现，而只是负责为它封装的组件提供额外的功能和数据。<br><img src="/images/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6.png" alt="高阶组件.png"></p>
<p>如上图，图中的三个圆圈代表三个组件，UI由组件树的方式来描述。当中间的蓝色组件需要一些属性时，他的父组件需要传递所有的属性给他，同样他也会把他的一些属性传给他的子组件。可以想到一个问题，如果一个组件的所有来自外部的属性都由他的父组件传递给他，那他的父组件需要知道这个组件的所有状态。如果相隔很多层节点，比如这个组件需要获取三层节点之上的节点的内部状态，则需要属性一层一层往下传，中间的两层完全不需要用到这个数据，它们接受属性的唯一目的只是为了把它往下传。我们便可以用高阶组件来解决这个问题。高阶组件可以自己去获取外部资源并对其做一定处理，然后把属性传递给封装前的组件。那么此时组件的数据便有了两个来源，一个是父组件传递给它的属性，另一个便是高阶组件传给它的一些属性。高阶组件产生一般是有个函数，这个函数接收一个组件作为参数，返回一个新的组件，我们把它叫做高阶组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const EnhancedComponent &#x3D; HighOrderComponent(wrappedComponent)</span><br></pre></td></tr></table></figure>

<p>我们来看一个高阶组件的应用场景。<br>现在有一个在界面上显示当前时间的组件，每一秒变化一次。现在我们需要重用这个组件，比如有一个聊天框，我们需要在下面显示当前的时间。我们可以看一下clock组件中的代码</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">componentWillUnmount() &#123;</span><br><span class="line">  clearInterval(this.timerID);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tick() &#123;</span><br><span class="line">  this.setState(&#123;</span><br><span class="line">    date: new Date()</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它的主要逻辑就是实现一个计时器。在didmount生成一个定时器，在willunmount清除这个计时器，有一个tick方法用来更新当前时间的状态。如果我们要在一个聊天功能的页面中有一个显示时间功能，可以在这个页面加上定时器的逻辑来实现，还一种方法是把clock组件直接放入其中。如果把clock组件引入，有一个问题，clock组件决定了时间显示成啥样，但是如果我们的聊天页面需要显示另外一种时间格式，那么会有一些麻烦。比如聊天功能我们只是需要一个计时器来知道每秒的时候，如何展示是自己来决定，但是又不想重复实现这个逻辑。此时，便可以引入高阶组件的概念。用高阶组件来实现计时器的逻辑，然后把这个时间传递给聊天页面。<br>我们可以写一个计时器的代码，用来产生高阶组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">export default function withTimer(WrappedComponent) &#123;</span><br><span class="line">  return class extends React.Component &#123;</span><br><span class="line">    state &#x3D; &#123; time: new Date() &#125;;</span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">      this.timerID &#x3D; setInterval(() &#x3D;&gt; this.tick(), 1000);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentWillUnmount() &#123;</span><br><span class="line">      clearInterval(this.timerID);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    tick() &#123;</span><br><span class="line">      this.setState(&#123;</span><br><span class="line">        time: new Date()</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">      return &lt;WrappedComponent time&#x3D;&#123;this.state.time&#125; &#123;...this.props&#125; &#x2F;&gt;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数可以给已有的组件注入一个计时器的功能。它接收一个组件作为参数，并且返回一个组件作为返回值。可以看到它内部有正常的生命周期方法，但是它的render函数并没有自己任何新的东西，只是把传入的组件render，但是会增加一些其他的属性。比如这里增加的是time属性。<br>回到聊天页面，我们想要在其中加入计时器的功能，便可以引入这个withTimer，我们现在导出的是封装后的高阶组件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;MessageList messages&#x3D;&#123;this.state.messages&#125; &#x2F;&gt;</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &lt;input value&#x3D;&#123;this.state.inputMsg&#125; &#x2F;&gt;</span><br><span class="line">          &lt;button onClick&#x3D;&#123;this.handleSend&#125;&gt;Send&lt;&#x2F;button&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;h2&gt;&#123;this.props.time.toLocaleString()&#125;&lt;&#x2F;h2&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default withTimer(ChatApp);</span><br></pre></td></tr></table></figure>
<p>此时，原组件有了time的属性，我们把它在render方法中展示出来，显示一个当前时间的字符串。我们可以看到时间已经在聊天页面展示了，但是我们并不是重用了clock组件，而是写了一个高阶组件的函数，这个函数实现了一个定时器的逻辑，把时间通过props传入原组件。同样的，我们需要在另一个组件中实现不同格式的时间，也是很容易的，只需要把props传入的时间通过另一种格式展示出来就ok了。<br>以上便是高阶组件的一个应用场景实例，它可以帮你去实现一些通用的逻辑被不同组件使用，但是它自身并没有任何UI展现。</p>
<p>2.函数作为子组件<br>函数作为子组件是一个设计模式而不是react一个新的特性。看如下代码，定义了一个myComponent。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class myComponent extends React.Component &#123;</span><br><span class="line">  render( ) &#123;</span><br><span class="line">    return (</span><br><span class="line">        &lt;div&gt;</span><br><span class="line">          &#123;this.props.children(&#39;able Feng&#39;)&#125;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">     );</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>它是直接调用了children这个函数，说明它已经假设传入的children为一个函数。使用的时候需要在mycomponent的子元素中定义一个函数，这个函数接收一个参数返回一个节点。我们不是直接把一个节点作为children，而是把一个函数作为children。这并不是react的一个特性，而是因为mycomponent已经决定了自己是如何使用children，因此它是一个设计模式而不是一种特殊类型组件。<br>看如下例子，我们用函数作为子组件的方式来实现让外部告知你如何显示你选中的状态。我们选中一个颜色它直接展示颜色，选中小动物直接展示小动物的图片。<br><img src="/images/selector.png" alt="函数子组件.jpg"><br>定义一个advancedtabselector组件，它有一个children的属性，我们定义为一个function，即可执行的。除了tab的选中逻辑，现在加入了一个额外的内容区域，this.props.children由外部决定如何render选中的值，如果有value便调用这个children的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">render()&#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &#123;this.props.value&amp;&amp;this.props.children(this.props.value)&#125;</span><br><span class="line">    &lt;&#x2F;&gt;</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用这个组件时，我们可以定义一个函数作为这个advancedtabselector组件的children。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;AdvancedTabSelector</span><br><span class="line">         options&#x3D;&#123;colors&#125;</span><br><span class="line">         value&#x3D;&#123;this.state.color&#125;</span><br><span class="line">         onChange&#x3D;&#123;c &#x3D;&gt; this.setState(&#123; color: c &#125;)&#125;</span><br><span class="line">       &gt;</span><br><span class="line">         &#123;color &#x3D;&gt; (</span><br><span class="line">           &lt;span</span><br><span class="line">             style&#x3D;&#123;&#123;</span><br><span class="line">               display: &quot;inline-block&quot;,</span><br><span class="line">               backgroundColor: color,</span><br><span class="line">               width: &quot;40px&quot;,</span><br><span class="line">               height: &quot;40px&quot;</span><br><span class="line">             &#125;&#125;</span><br><span class="line">           &#x2F;&gt;</span><br><span class="line">         )&#125;</span><br><span class="line">       &lt;&#x2F;AdvancedTabSelector&gt;</span><br></pre></td></tr></table></figure>
<p>它的参数是当前颜色，我们来决定它如何显示颜色，例子中用span来展示颜色。同样的，如果选中是一个animal，定义一个函数接收animal作为参数，渲染出来一个图片。可以看到函数作为子组件有一个特点，一个组件如何render它的内容可以由使用者来决定，对于这个tabselector如何render选中的状态，可以由用tabselector的人来决定，而不是在组件内部不停增加自身功能来适配外部的使用场景，这样组件内部可以只有很小的scope，它的灵活性可以由函数作为子组件来决定。</p>
<p>3.总结：<br>组件复用的两种形式——高阶组件和函数作为子组件均为使用react的组件的新的方式，称为设计模式，而不是代表react有两种新类型的组件。在工作开发中我们可以结合业务场景去使用这两种设计模式。`</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/" data-id="ck8edvsxi0000h65x7s5j13i3" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/03/17/hello-world/" class="article-date">
  <time datetime="2020-03-17T09:02:40.435Z" itemprop="datePublished">2020-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2020/03/17/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/03/17/hello-world/" data-id="ck7vqnmuf0000845xc687h600" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/04/24/React%E6%96%B0%E7%89%88%E6%9C%AC%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%8F%8A%E6%9B%BF%E6%8D%A2%E6%96%B9%E6%A1%88/">React新版本生命周期及替换方案</a>
          </li>
        
          <li>
            <a href="/2020/03/17/%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%E5%92%8C%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%AD%90%E7%BB%84%E4%BB%B6/">高阶组件和函数作为子组件</a>
          </li>
        
          <li>
            <a href="/2020/03/17/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>