<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:type" content="website">
<meta property="og:title" content="无名之辈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="无名之辈">
<meta property="og:description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="前端一岁小白-able.Feng">
<meta name="twitter:card" content="summary"><meta name="keywords" content="前端一岁小白-able.Feng, 无名之辈"><meta name="description" content="谁不是，拼了命走到生命的结尾"><title>无名之辈</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">无名之辈</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/09/25/Ts%E5%87%BD%E6%95%B0/">Ts函数</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-09-25</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在 TypeScript 里定义函数时，我们可以显式指定函数参数和返回值的类型：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = (a: number, <span class="attr">b</span>: number): <span class="function"><span class="params">number</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>返回值类型<br>在 JavaScript 中，我们知道一个函数可以没有显式 return，此时函数的返回值应该是 undefined：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(func()); <span class="comment">// =&gt; undefined</span></span><br></pre></td></tr></table></div></figure>
<p>需要注意的是，在 TypeScript 中，如果我们显式声明函数的返回值类型为 undfined，将会得到如下所示的错误提醒。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>): <span class="title">undefined</span> </span>&#123; <span class="comment">// 其声明类型不为 "void" 或 "any" 的函数必须返回值。ts(2355)</span></span><br><span class="line">  <span class="comment">// do sth</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此时，正确的做法是使用 03 讲介绍的 void 类型来表示函数没有返回值的类型（这是“废柴” void 类型唯一有用的场景），示例如下：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params"></span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line">funcA().doSomething(); <span class="comment">// 类型“void”上不存在属性“doSomething”。ts(2339)</span></span><br></pre></td></tr></table></div></figure>
<p>我们可以使用类似定义箭头函数的语法来表示函数类型的参数和返回值类型，此时=&gt; 类型仅仅用来定义一个函数类型而不用实现这个函数。</p>
<p>需要注意的是，这里的=&gt;与 ES6 中箭头函数的=&gt;有所不同。TypeScript 函数类型中的=&gt;用来表示函数的定义，其左侧是函数的参数类型，右侧是函数的返回值类型；而 ES6 中的=&gt;是函数的实现。</p>
<p>如下示例中，我们定义了一个函数类型,并且使用箭头函数实现了这个类型。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">type Adder = <span class="function">(<span class="params">a: number, b: number</span>) =&gt;</span> number; <span class="comment">// TypeScript 函数类型定义</span></span><br><span class="line"><span class="keyword">const</span> add: Adder = <span class="function">(<span class="params">a, b</span>) =&gt;</span> a + b; <span class="comment">// ES6 箭头函数</span></span><br></pre></td></tr></table></div></figure>

<p>在对象（即接口类型，详见 07 讲）中，除了使用这种声明语法，我们还可以使用类似对象属性的简写语法来声明函数类型的属性，如下代码所示：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">interface Entity &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">m: number, n: number</span>) =&gt;</span> number;</span><br><span class="line">    del(m: number, <span class="attr">n</span>: number): number;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> entity: Entity = &#123;</span><br><span class="line">    add: <span class="function">(<span class="params">m, n</span>) =&gt;</span> m + n,</span><br><span class="line">    del(m, n) &#123;</span><br><span class="line">      <span class="keyword">return</span> m - n;</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>

<p>可缺省和可推断的返回值类型<br>很多时候，我们不必或者不能显式地指明返回值的类型，这就涉及可缺省和可推断的返回值类型的讲解。<br>函数内是一个相对独立的上下文环境，我们可以根据入参对值加工计算，并返回新的值。从类型层面看，我们也可以通过类型推断加工计算入参的类型，并返回新的类型，示例如下：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">generateTypes</span>(<span class="params">m: string, n: number</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> numbers = [n];</span><br><span class="line">  <span class="keyword">const</span> strings = [m]</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    numbers,</span><br><span class="line">    strings</span><br><span class="line">  &#125; <span class="comment">// 返回 &#123; numbers: number[]; strings: string[] &#125; 的类型 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>参数类型</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x?: string</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log1</span>(<span class="params">x: string | undefined</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line">log();</span><br><span class="line">log(<span class="literal">undefined</span>);</span><br><span class="line">log1(); <span class="comment">// 应有 1 个参数，但获得 0 个。ts(2554)</span></span><br><span class="line">log1(<span class="literal">undefined</span>);</span><br></pre></td></tr></table></div></figure>
<p>这里的 ?: 表示参数可以缺省、可以不传，也就是说调用函数时，我们可以不显式传入参数。但是，如果我们声明了参数类型为 xxx | undefined，就表示函数参数是不可缺省且类型必须是 xxx 或者 undfined。因此，在上述代码中，log1 函数如果不显示传入函数的参数，TypeScript 就会报一个 ts(2554) 的错误，即函数需要 1 个参数，但是我们只传入了 0 个参数。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/08/22/TS%E5%AD%97%E9%9D%A2%E9%87%8F%E7%B1%BB%E5%9E%8B/">TS字面量类型</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-08-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在 TypeScript 中，类型标注声明是在变量之后（即类型后置），它不像 Java 语言一样，先声明变量的类型，再声明变量的名称。<br>使用类型标注后置的好处是编译器可以通过代码所在的上下文推导其对应的类型，无须再声明变量类型。在 TypeScript 中，具有初始化值的变量、有默认值的函数参数、函数返回的类型都可以根据上下文推断出来。<br>正是得益于 TypeScript 这种类型推导机制和能力，使得我们无须显式声明，即可直接通过上下文环境推断出变量的类型，也就是说此时类型可缺省。<br>如下所示，我们发现这些缺省类型注解的变量可以通过类型推断出类型。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="string">'it is a string'</span>;</span><br><span class="line">  <span class="keyword">let</span> number = <span class="number">666</span>;</span><br><span class="line">  <span class="keyword">let</span> boolean = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> string = <span class="string">'it is a string'</span>; </span><br><span class="line">  <span class="keyword">const</span> number = <span class="number">666</span>;</span><br><span class="line">  <span class="keyword">const</span> boolean = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>我们通过 VS Code hover 示例中的变量查看类型，可以发现一个很神奇的事情。通过 let 和 const 定义的赋予了相同值的变量，其推断出来的类型不一样。比如同样是 ‘it is a string’，通过 let 定义的变量类型是 string，而通过 const 定义的变量类型是 ‘it is a string’’（这里表示一个字符串字面量类型）。<br><img src='/images/TS字面量类型1.png' width='500px' height='300px'><br><img src='/images/TS字面量类型2.png' width='500px' height='300px'></p>

        <h3 id="字面量类型"   >
          <a href="#字面量类型" class="heading-link"><i class="fas fa-link"></i></a>字面量类型</h3>
      <p>在 TypeScript 中，字面量不仅可以表示值，还可以表示类型，即所谓的字面量类型。<br>目前，TypeScript 支持 3 种字面量类型：字符串字面量类型、数字字面量类型、布尔字面量类型，对应的字符串字面量、数字字面量、布尔字面量分别拥有与其值一样的字面量类型，字面量类型是集合类型的子类型，它是集合类型的一种更具体的表达。比如 ‘it is a string’ （这里表示一个字符串字面量类型）类型是 string 类型（确切地说是 string 类型的子类型），而 string 类型不一定是 ‘it is astring’（这里表示一个字符串字面量类型）类型。<br>一般来说，我们可以使用一个字符串字面量类型作为变量的类型，如下代码所示：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> userName: <span class="string">'able'</span> = <span class="string">'able'</span>;</span><br><span class="line">userName = <span class="string">'moriaty'</span>;<span class="comment">//不能将类型“"moriaty"”分配给类型“"able"”。ts(2322)</span></span><br></pre></td></tr></table></div></figure>
<p>实际上，定义单个的字面量类型并没有太大的用处，它真正的应用场景是可以把多个字面量类型组合成一个联合类型，用来描述拥有明确成员的实用的集合。<br>如下代码所示，我们使用字面量联合类型描述了一个明确、可 ‘up’ 可 ‘down’ 的集合，这样就能清楚地知道需要的数据结构了。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">type sportsType = <span class="string">'basketball'</span> | <span class="string">'footbal'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">exercise</span>(<span class="params">type: sportsType</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line">exercise(<span class="string">'basketball'</span>); </span><br><span class="line">exercise(<span class="string">'run'</span>); <span class="comment">// 类型“"run"”的参数不能赋给类型“sportsType”的参数。ts(2345)</span></span><br></pre></td></tr></table></div></figure>
<p>通过使用字面量类型组合的联合类型，我们可以限制函数的参数为指定的字面量类型集合，然后编译器会检查参数是否是指定的字面量类型集合里的成员。<br>因此，相较于使用 string 类型，使用字面量类型（组合的联合类型）可以将函数的参数限定为更具体的类型。这不仅提升了程序的可读性，还保证了函数的参数类型，可谓一举两得。<br>数字字面量类型和布尔字面量类型的使用与字符串字面量类型的使用类似，我们可以使用字面量组合的联合类型将函数的参数限定为更具体的类型。</p>

        <h3 id="字面量类型拓宽"   >
          <a href="#字面量类型拓宽" class="heading-link"><i class="fas fa-link"></i></a>字面量类型拓宽</h3>
      <p>所有通过 let 或 var 定义的变量、函数的形参、对象的非只读属性，如果满足指定了初始值且未显式添加类型注解的条件，那么它们推断出来的类型就是指定的初始值字面量类型拓宽后的类型，这就是字面量类型拓宽。<br>下面我们通过字符串字面量的示例来理解一下字面量类型拓宽：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> string = <span class="string">'it is a string'</span>; <span class="comment">// 类型是 string</span></span><br><span class="line">  <span class="keyword">let</span> stringFunc = <span class="function">(<span class="params">str = <span class="string">'it is a string'</span></span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line">  <span class="keyword">const</span> specifiedStr = <span class="string">'it is a string'</span>; <span class="comment">// 类型是 'it is a string'</span></span><br><span class="line">  <span class="keyword">let</span> strNew = specifiedStr; <span class="comment">// 类型是 'string'</span></span><br><span class="line">  <span class="keyword">let</span> stringFuncNew = <span class="function">(<span class="params">str = specifiedStr</span>) =&gt;</span> str; <span class="comment">// 类型是 (str?: string) =&gt; string;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为string和stringFunc满足了 let、形参且未显式声明类型注解的条件，所以变量、形参的类型拓宽为 string（形参类型确切地讲是 string | undefined）。<br>因为specifiedStr的常量不可变更，类型没有拓宽，所以 specifiedStr 的类型是 ‘it is a string’ 字面量类型。<br>因为strNew赋予的值 specifiedStr 的类型是字面量类型，且没有显式类型注解，所以变量、形参的类型也被拓宽了。其实，这样的设计符合实际编程诉求。我们设想一下，如果 strNew 的类型被推断为 ‘this is string’，它将不可变更，因为赋予任何其他的字符串类型的值都会提示类型错误。<br>但是要注意一点，如果添加显示类型注解，则能控制类型拓宽行为。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> specifiedStr: <span class="string">' it is a string'</span> = <span class="string">'it is a string'</span>; <span class="comment">// 类型是 '"it is a string"'</span></span><br><span class="line">  <span class="keyword">let</span> str2 = specifiedStr; <span class="comment">// 即便使用 let 定义，类型是 'it is a string'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/07/23/%E5%89%8D%E7%AB%AF%E4%B8%89%E5%A4%A7%E6%A1%86%E6%9E%B6%E5%AF%B9%E6%AF%94/">前端三大框架对比</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-07-23</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>Angular 是一个应用设计框架与开发平台，用于创建高效、复杂、精致的单页面应用，提供了前端项目开发较完整的解决方案。<br>与此相对，React/Vue 则专注于构建用户界面，在一定程度上来说是一个 JavaScript 库，不能称之为框架。<br>由于 React/Vue 都提供了配套的页面应用解决方案和工具库，因此我们常常将它们作为前端框架与 Angular放在一起比较。<br>实际上，三个框架的关系可以简单用这样的公式表达。<br>Angular = React/Vue + 路由库（react-router/vue-router） + 状态管理（Redux/Flux/Mobx/Vuex） + 脚手架/构建（create-react-app/Vue CLI/Webpack） + …<br>我们先来看看 Angular。</p>

        <h3 id="Angular"   >
          <a href="#Angular" class="heading-link"><i class="fas fa-link"></i></a>Angular</h3>
      <p>Angular 最初的设计是针对大型应用进行的，上手成本较高，因为开发者需要掌握一些对前端开发来说较陌生的概念，其中包括依赖注入、模块化、脏检查、AOT 等设计。</p>

        <h5 id="依赖注入"   >
          <a href="#依赖注入" class="heading-link"><i class="fas fa-link"></i></a>依赖注入</h5>
      <p>在项目中，依赖注入体现为：项目提供了这样一个注入机制，其中有人负责提供服务、有人负责消耗服务，通过注入机制搭建了提供服务与消费服务之间的接口。Angular 通过依赖注入来帮我们更容易地将应用逻辑分解为服务，并让这些服务可用于各个组件中。前面提到，Angular 的设计是针对大型应用的，使用依赖注入可以轻松地将各个模块进行解耦，模块与模块之间不会有过多的依赖，可以轻松解决大型应用中模块难以管理的难题。所以在 Angular 中，依赖注入配合模块化组织能达到更好的效果。</p>

        <h5 id="模块化组织"   >
          <a href="#模块化组织" class="heading-link"><i class="fas fa-link"></i></a>模块化组织</h5>
      <p>Angular 模块把组件、指令和管道打包成内聚的功能块，每个模块聚焦一个特性区域、业务领域、工作流或通用工具。所以我们可以用Angular 模块来自行聚焦某一个领域的功能模块，也可以使用 Angular 封装好的一些功能模块，像表单模块 FormModule、路由模块 RouterModule、Http 模块，等等。通过依赖注入的方式，我们可以直接在需要的地方引入这些模块并使用。模块的组织结构为树状结构，不同层级的模块功能组成了完整的应用。通过树状的方式来，依赖注入系统可高效地对服务进行创建和销毁，管理各个模块之间的依赖关系。<br>状态更新：脏检查机制<br>在 Angular 中，触发视图更新的时机来自常见的事件如用户交互（点击、输入等）、定时器、生命周期等，大概的过程如下：<br>在上述时机被触发后，Angular会计算数据的新值和旧值是否有差异；<br>若有差异，Angular 会更新页面，并触发下一次的脏检查；<br>直到新旧值之间不再有差异，或是脏检查的次数达到设定阈值，才会停下来。<br>由于并不是直接监听数据的变动，同时每一次更新页面之后，很可能还会引起新的值改变，这导致脏检查的效率很低，还可能会导致死循环。虽然 AngularJS 有阈值控制，但也无法避免脏检查机制所导致的低效甚至性能问题。<br>脏检查机制在设计上存在的性能问题一直被大家诟病，在 Angular2+ 中引入了模块化组织来解决这个问题。由于应用的组织类是树结构的，脏检查会从根组件开始，自上而下对树上的所有子组件进行检查。相比 AngularJS 中的带有环的结构，这样的单向数据流效率更高，而且容易预测，性能上也有不少的提升。除了模块化组织之外，Angular2+ 同时还引入了 NgZone，提升了脏检查的性能。<br>在 Angular 中除了对脏检查机制进行了性能优化，还提供了其他的优化手段，AOT 编译便是其中一种。</p>

        <h5 id="用-AOT-进行编译"   >
          <a href="#用-AOT-进行编译" class="heading-link"><i class="fas fa-link"></i></a>用 AOT 进行编译</h5>
      <p>Angular 提供了预编译（AOT）能力，无须等待应用首次编译，以及通过预编译的方式移除不需要的库代码、减少体积，还可以提早检测模板错误。<br>除此之外，Angular提供了完备的结构和规范，新加入的成员能很快地通过复制粘贴完成功能的开发。好的架构设计，能让高级程序员和初入门的程序员写出相似的代码，Angular 通过严格的规范约束，提升了项目的维护体验。<br>由于 Angular 目标是提供大而全的解决方案，因此相比 Angular，React和 Vue则更专注于用户界面的构建和优化，我们继续来看一下 React。</p>

        <h3 id="React"   >
          <a href="#React" class="heading-link"><i class="fas fa-link"></i></a>React</h3>
      <p>React 和 Vue 都是专注于构建用户界面的 JavaSctipt 库，它们不强制引入很多工程类的功能，也没有过多的强侵入性的概念、语法糖和设计，因此它们相对 Angular 最大的优势是轻量。<br>而对比 Vue，React 最大的优点是灵活，对原生 JavaScript 的侵入性弱（没有过多的模板语法），不需要掌握太多的API 也可以很好地使用。<br>接下来，我们来看看React 中的一些核心设计和特色，首选便是虚拟 DOM的设计。</p>

        <h5 id="虚拟-DOM"   >
          <a href="#虚拟-DOM" class="heading-link"><i class="fas fa-link"></i></a>虚拟 DOM</h5>
      <p>虚拟 DOM 方案的出现，主要为了解决前端页面频繁渲染过程中的性能问题。该方案最初由 React 提出，如今随着机器性能的提升、框架之间的相互借鉴等，在其他框架（比如 Vue）中也都有使用。<br>虚拟 DOM的设计，大概可分成 3 个过程，下面我们分别来看看。<br>1.用JavaScript 对象模拟 DOM 树，得到一棵虚拟 DOM 树。<br>2.当页面数据变更时，生成新的虚拟 DOM 树，比较新旧两棵虚拟 DOM 树的差异。<br>3.把差异应用到真正的 DOM 树上。<br>虽然虚拟 DOM 解决了页面被频繁更新和渲染带来的性能问题，但传统虚拟 DOM 依然有以下性能瓶颈：<br>在单个组件内部依然需要遍历该组件的整个虚拟 DOM 树；<br>在一些组件整个模版内只有少量动态节点的情况下，这些遍历都是性能的浪费；<br>递归遍历和更新逻辑容易导致 UI 渲染被阻塞，用户体验下降。<br>对此，React 框架也有进行相应的优化：使用任务调度来控制状态更新的计算和渲染。</p>

        <h5 id="状态更新：任务调度"   >
          <a href="#状态更新：任务调度" class="heading-link"><i class="fas fa-link"></i></a>状态更新：任务调度</h5>
      <p>React 中使用协调器（Reconciler）与渲染器（Renderer）来优化页面的渲染性能。<br>在 React 里，可以使用ReactDOM.render/this.setState/this.forceUpdate/useState等方法来触发状态更新，这些方法共用一套状态更新机制，该更新机制主要由两个步骤组成。<br>找出变化的组件，每当有更新发生时，协调器会做如下工作：<br>调用组件render方法将 JSX 转化为虚拟 DOM；<br>进行虚拟 DOM Diff 并找出变化的虚拟 DOM；<br>通知渲染器。<br>渲染器接到协调器通知，将变化的组件渲染到页面上。<br>在 React15 及以前，协调器创建虚拟 DOM 使用的是递归的方式，该过程是无法中断的。这会导致 UI 渲染被阻塞，造成卡顿。<br>为此，React16 中新增了调度器（Scheduler），调度器能够把可中断的任务切片处理，能够调整优先级，重置并复用任务。调度器会根据任务的优先级去分配各自的过期时间，在过期时间之前按照优先级执行任务，可以在不影响用户体验的情况下去进行计算和更新。<br>通过这样的方式，React 可在浏览器空闲的时候进行调度并执行任务，篇幅关系这里不再展开。<br>虚拟DOM和任务调度的状态更新机制，是 React 中性能优化的两个重要解决方案。<br>除了性能优化以外，React 的出现同时带来了特别棒的理念和设计，包括 jsx、函数式编程、Hooks等。其中，函数式编程的无副作用等优势向来被很多程序员所推崇，Hooks 的出现更是将 React 的函数式编程理念推向了更高峰。<br>相比于 Angular，React 的入门门槛要低很多，但提到简单易学，就不得不说到 Vue了。</p>

        <h3 id="Vue"   >
          <a href="#Vue" class="heading-link"><i class="fas fa-link"></i></a>Vue</h3>
      <p>Vue 最大的特点是上手简单，框架的设计和文档对新手极其友好。但这并不代表它只是个简单的框架，当你需要实现一些更加深入的自定义功能时（比如自定义组件、自定义指令、JSX 等），你会发现它也提供了友好的支持能力。<br>很多人会认为 Vue 只是把 Angular 和 React 的优势结合，但 Vue 也有自身的设计和思考特色。这里，我们同样介绍一下 Vue 的设计特点。</p>

        <h5 id="虚拟-DOM-1"   >
          <a href="#虚拟-DOM-1" class="heading-link"><i class="fas fa-link"></i></a>虚拟 DOM</h5>
      <p>前面我们在介绍 React的虚拟 DOM时，提到传统虚拟 DOM的性能瓶颈，Vue 3.0 同样为此做了些优化。<br>在 Vue 3.0 中，虚拟 DOM通过动静结合的模式来进行突破：<br>通过模版静态分析生成更优化的虚拟 DOM 渲染函数，将模版切分为块（if/for/slot)；<br>更新时只需要直接遍历动态节点，虚拟 DOM的更新性能与模版大小解耦，变为与动态节点的数量相关。<br>可以简单理解为，虚拟 DOM 的更新从以前的整体作用域调整为树状作用域，树状的结构会带来算法的简化以及性能的提升。</p>

        <h5 id="状态更新：-getter-setter、Proxy"   >
          <a href="#状态更新：-getter-setter、Proxy" class="heading-link"><i class="fas fa-link"></i></a>状态更新： getter/setter、Proxy</h5>
      <p>在 Vue 3.0 以前，Vue中状态更新实现主要依赖了getter/setter，在数据更新的时候就执行了模板更新、watch、computed等一些工作。<br>相比于之前的getter/setter监控数据变更，Vue 3.0 将会是基于Proxy的变动侦测，通过代理的方式来监控变动，整体性能会得到优化。当我们给某个对象添加了代理之后，就可以改变一些原有的行为，或是通过钩子的方式添加一些处理，用来触发界面更新、其他数据更新等也是可以的。<br>对比 Angular，Vue 更加轻量、入门容易。对比 React，Vue 则更专注于模板相关，提供了便利和易读的模板语法，开发者熟练掌握这些语法之后，可快速高效地搭建起前端页面。同时，Vue也在不断地进行自我演化，这些我们也能从 Vue 3.0 的响应式设计、模块化架构、更一致的API 设计等设计中观察到。</p>

        <h4 id="小结"   >
          <a href="#小结" class="heading-link"><i class="fas fa-link"></i></a>小结</h4>
      <p>前端框架很大程度地提升了前端的开发效率，同时提供了各种场景下的解决方案，使得前端开发可以专注于快速拓展功能和业务实现。。其中，Angular 属于适合大型前端项目的“大而全”的框架，而 React/Vue 则是轻量灵活的库，它们各有各的设计特点。<br>对于框架的升级，React 选择了渐进兼容的技术方案，而 Angular/Vue 都曾经历过“断崖式”的版本升级。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/06/26/es2021%E6%96%B0%E7%89%B9%E6%80%A7/">ES2021新特性</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>ECMAScript 2021 新特性</p>
<p>1 String.prototype.replaceAll()<br>在JavaScript中，replace()方法只替换字符串中的第一个实例。如果我们想替换字符串中的所有匹配项，唯一的办法就使用全局正则表达式。<br>新特性replaceAll()会返回一个新的字符串，字符串中所有的匹配项都会被替换掉。模式可以是字符串或正则表达式，替换的内容可以是字符串或是为每个匹配项执行的函数。</p>
<p>原本的replace()只能替换掉第一个匹配项：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批 "</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replace(<span class="string">"审批"</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// 人事 审批 审批 审批</span></span><br></pre></td></tr></table></div></figure>
<p>如果想要完全匹配替换需要写全局正则表达式：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批"</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replace(<span class="regexp">/审批/g</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// 人事 人事 人事 人事</span></span><br></pre></td></tr></table></div></figure>
<p>新的replaceAll()特性：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批"</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replaceAll(<span class="string">"审批"</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">//人事 人事 人事 人事</span></span><br></pre></td></tr></table></div></figure>

<p>2 Promise.any<br>ES2020已经通过了Promise的allSettled()方法。ES2021 Promise阵营将有一个新的成员，any()。<br>当Promise列表中的任意一个promise成功resolve则会短路并返回第一个resolve的结果状态， 如果所有的promise均reject，则抛出异常AggregateError，表示所有请求失败。<br>Promise.any()与Promise.race()十分容易混淆，务必注意区分。Promise.race() 一旦某个promise触发了resolve或者reject，就直接返回了该状态的结果。<br>即使Promise在resolve的之前被reject，Promise.any()仍将返回第一个resolve的结果：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject(<span class="string">'workflow'</span>), <span class="number">100</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve(<span class="string">'staff'</span>), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve(<span class="string">'holiday'</span>), <span class="number">2000</span>))</span><br><span class="line">])</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;value&#125;</span>`</span>)) <span class="comment">// 结果：staff</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></div></figure>
<p>当所有promise都为reject会抛出异常AggregateError: All promises were rejected：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error one'</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error two'</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error three'</span>)</span><br><span class="line">])</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// AggregateError: All promises were rejected</span></span><br></pre></td></tr></table></div></figure>
<p>3 逻辑运算符和赋值表达式<br>在JavaScript中，有很多赋值操作符和逻辑操作符，在新的草案下，我们可以组合逻辑运算符和赋值运算符。<br>a &amp;&amp;= b 当a值存在时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp;= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1. a &amp;&amp; (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (a) a = b</span></span><br></pre></td></tr></table></div></figure>
<p>a ||= b 当a值不存在时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a ||= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1. a || (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (!a) a = b</span></span><br></pre></td></tr></table></div></figure>
<p>a ??= b 当a值为null或者undefined时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navigations = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'工作台'</span>,</span><br><span class="line">        path: <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'审批'</span>,</span><br><span class="line">        path: <span class="string">'/workflow'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/setting'</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> navigation <span class="keyword">of</span> navigations) &#123;</span><br><span class="line">    page.title ??= <span class="string">'默认'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(pages);</span><br><span class="line"></span><br><span class="line"><span class="comment">//   (index)            title                     path</span></span><br><span class="line"><span class="comment">//   0                  "工作台"           "/"</span></span><br><span class="line"><span class="comment">//   1                  "审批"                "/workflow"</span></span><br><span class="line"><span class="comment">//   2                  "默认"                "/setting"</span></span><br></pre></td></tr></table></div></figure>
<p>4 Private Methods &amp; Private Accessors</p>
<p>4.1 私有方法 Private Methods</p>
<p>私有方法只能在定义它的类内部访问，专用方法名称以#开头。由于setType()是私有方法，所以personObj.setType返回undefined，用undefined作函数会引发TypeError。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Private method</span></span><br><span class="line">    ﻿#setType() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Private'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Public method</span></span><br><span class="line">    show() &#123;</span><br><span class="line">        this.#setType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personObj = <span class="keyword">new</span> Person();</span><br><span class="line">personObj.show(); <span class="comment">// "Private"</span></span><br><span class="line">personObj.setType(); <span class="comment">// TypeError: personObj.setType is not a function</span></span><br></pre></td></tr></table></div></figure>
<p>4.2 私有访问者 Private Accessors</p>
<p>可以通过在函数名称前添加#，使得访问器函数私有。在下面的代码中，name是公共的，可以像普通属性一样读取它, 而age则是私有。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Public accessor</span></span><br><span class="line">    ﻿<span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'able'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> name(value) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Private accessor</span></span><br><span class="line">﻿    <span class="keyword">get</span> #age() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> #age(value) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personObj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(personObj.name); <span class="comment">// "able"</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></div></figure>
<p>5 WeakRefs</p>
<p>当我们通过const, let, var创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在且可访问。而WeakRef对象包含针对对象的弱引用，针对对象的弱引用是不会阻止垃圾收集器GC的回收的，则GC可以在任何时候删除它。</p>
<p>例如有如下场景：<br>跟踪某个对象调用某一特定方法的次数，超过1000条则做对应提示。</p>
<p>如果我们使用Map，虽然可以实现需求，但是会发生内存溢出，因为传递给doSomething()的每个对象都永久保存在map中，并且不会被GC回收。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomething(obj);</span><br><span class="line">    <span class="keyword">let</span> called = map.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用次数已超过1000次'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomething(obj);</span><br><span class="line">    <span class="keyword">let</span> called = wmap.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用次数已超过1000次'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wmap.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为是弱引用，所以WeakMap、WeakSet的键值对是不可枚举的。WeakSet和WeakMap相似，但是每个对象在WeakSet中只可能出现一次，WeakSet中所有对象都是唯一的。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(foo);</span><br><span class="line">ws.add(bar);</span><br><span class="line"></span><br><span class="line">ws.has(foo); <span class="comment">// true</span></span><br><span class="line">ws.has(bar); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">ws.delete(foo); <span class="comment">// 删除foo对象</span></span><br><span class="line"></span><br><span class="line">ws.has(foo); <span class="comment">//false foo已删除</span></span><br><span class="line">ws.has(bar); <span class="comment">// bar仍存在</span></span><br></pre></td></tr></table></div></figure>
<p>WeakSet与Set相比有以下两个区别：<br>WeakSet只能是对象集合，而不能是任何类型的任意值<br>WeakSet弱引用，集合中对象引用为弱引用，如果没有其他对WeakSet对象的引用，则会被GC回收</p>
<p>最后，WeakRef实例有一个方法deref()，返回引用的原始对象，如果原始对象被回收，则返回undefined。下面其在斐波那契数列计算中缓存的妙用：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setValue = <span class="function">(<span class="params">key, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    cache.set(key, <span class="keyword">new</span> WeakRef(obj));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getValue = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">        <span class="keyword">return</span> ref.deref();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fibonacciCached = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cached = getValue(number);</span><br><span class="line">    <span class="keyword">if</span> (cached) <span class="keyword">return</span> cached;</span><br><span class="line">    <span class="keyword">const</span> sum = calculateFibonacci(number);</span><br><span class="line">    setValue(number, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8C%89%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/">为什么代码没有按编写顺序执行</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-04-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>前端工程师算是最幸运的软件工程师，因为从一开始就可以接触到“异步”这种高级特性，比如 DOM 事件、AJAX 请求及定时器；同时也是最不幸的软件工程师，因为入门 JavaScript 的时候就要习惯异步这种高难度的开发方式，异步经常会导致输出的结果与我们的预期不一致。</p>

        <h4 id="异步和同步"   >
          <a href="#异步和同步" class="heading-link"><i class="fas fa-link"></i></a>异步和同步</h4>
      <p>这两个概念大家应该都比较熟悉啦，简单解释一下，要比较同步和异步，可以将调用函数的过程分成两部分：执行操作和返回结果。程序在同步调用函数的时候，会立即执行操作并等待得到返回结果后再继续运行，也就是说同步执行是阻塞的。而异步会将操作和结果在时间上分隔开来，在当下执行操作，在未来某个时刻返回结果，在这个等待返回结果的过程中，程序将继续执行后面的代码。也就是说异步执行是非阻塞的。这里就不举🌰啦。</p>

        <h4 id="异步与回调"   >
          <a href="#异步与回调" class="heading-link"><i class="fas fa-link"></i></a>异步与回调</h4>
      <p>我们经常调用 JavaScript 的异步函数可能会认为：异步操作都采用回调函数的形式。毕竟从浏览器端的 DOM 事件、AJAX 请求、定时器到 Node.js 端的文件读写、多进程，都是采用的回调形式。那么还会有其他case嘛，上🌰。<br>下面是一段简单的代码，定义了一个 JSON 对象 a，然后把它打印到控制台，最后再将对象 a 的 couter.index 属性值自增 1。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  counter: &#123;</span><br><span class="line">    index: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ?</span></span><br><span class="line">a.counter.index++;</span><br></pre></td></tr></table></div></figure>
<p>我们在控制台里看一下，结果可能和我们的预期不一致，输出了一个JSON 对象：{conter:{index: 2}}。原因在于浏览器在运行代码的时候，把控制台打印这种涉及 I/O 的操作进行了延迟执行。可能有人会推测是不是控制台打印的只是将对象 a 进行了类似“浅拷贝”的操作，否定这种猜想很简单，此时再执行一次自增操作，就会发现被打印的对象值并没有发生变化。<br>既然并非所有异步都回调，那么反过来，是否所有回调函数都是异步执行的呢？答案也是否定的。比如数组原型函数 forEach，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里的回调就是同步的。</p>

        <h4 id="异步原理"   >
          <a href="#异步原理" class="heading-link"><i class="fas fa-link"></i></a>异步原理</h4>
      <p>回顾了异步的基础概念，下面就来深入讲解异步的原理。</p>

        <h5 id="事件循环"   >
          <a href="#事件循环" class="heading-link"><i class="fas fa-link"></i></a>事件循环</h5>
      <p>对于大多数语言而言，实现异步会通过启动额外的进程、线程或协程来实现，而我们在前面已经提到过，JavaScript 是单线程的。为什么单线程还能实现异步呢？其实也没有什么特殊的黑魔法，只是把一些操作交给了其他线程处理，然后采用了一种称之为“事件循环”（也称“事件轮询”）的机制来处理返回结果。<br>下面我们用一段简化的代码，来描述事件循环机制。<br>数组 eventLoop 表示事件队列（也有称作“任务队列”），用来存放需要执行的任务事件（可以理解为回调函数），对象 event 变量表示当前需要执行的任务事件。用一个永不停止的 while 循环来表示事件循环，每一次循环称为一个 tick。对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中获取一个事件并执行，这些事件通常是回调函数的形式。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventLoop = []; <span class="comment">// 事件队列，先进先出</span></span><br><span class="line"><span class="keyword">var</span> event; <span class="comment">// 事件执行成功的回调回调函数</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 一次tick</span></span><br><span class="line">  <span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 队列中取出回调函数</span></span><br><span class="line">    event = eventLoop.shift();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      event();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reportError(err); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>那么这个事件队列里的事件是怎么来的呢？以 AJAX 请求为例，当我们发出一个 AJAX 请求时，浏览器会将请求任务分派给网络线程来进行处理，当对应的网络线程拿到返回的数据之后，就会把回调函数插入到事件队列中。setTimeout 和 setInterval 也是同样的道理，当我们执行 setTimeout 的时候并不是直接把回调函数放入事件队列中。它所做的是交给定时器线程来处理，当定时器到时后，再把回调函数放在事件队列中，这样，在未来的某轮 tick 中获取并执行这个回调函数。这么做有一个隐性的问题，如果事件队列中已经有其他事件，那么这个回调就会排队等待。所以说 setTimeout/setInterval 定时器的精度并不高。准确地说，它只能确保回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，这就要根据事件队列的状态而定。</p>

        <h5 id="事件队列"   >
          <a href="#事件队列" class="heading-link"><i class="fas fa-link"></i></a>事件队列</h5>
      <p>在讲述 setTimeout/setInterval 原理的时候也暴露了事件队列的一个缺陷：事件队列按照先进先出的顺序执行，那么如果队列较长时，排在后面的事件即使较为“紧急”，也得需要等待前面的任务先执行完成。JavaScript 解决这个问题的思路就是：设置多个队列，按照优先级来执行。<br>下面这段代码可以验证 JavaScript 内部拥有优先级不同的 2 个队列，我们暂时称为红色队列和绿色队列，其中红色队列优先级高于绿色队列。这段代码定义了 4 个异步函数 f1、f2、f3、f4，其中：函数 f1 通过定时器 setTimeout 向绿色队列中插入一个控制台打印任务，输出数字 1；函数 f2 通过 Promise 向红色队列中插入一个控制台打印任务，输出数字 2；函数 f3 通过定时器 setTimeout 向绿色队列中插入一个回调函数，该回调函数会调用控制台打印数字 3，并且调用函数 f2；函数 f4 通过 Promise 向红色队列中插入一个回调函数，该回调函数会调用控制台打印数字 4，并且调用函数 f1。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    f2()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    f1()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">f3()</span><br><span class="line">f4()</span><br></pre></td></tr></table></div></figure>
<p>当调用函数 f3 和函数 f4 之后，绿色队列和红色队列都会被插入一个匿名回调函数。第 1 次 tick，由于红色队列优先级高，所以先执行红色匿名函数，控制台打印数字 4，然后调用函数 f1，向绿色队列中插入一个打印函数；第 2 次 tick，按照先进先出原则，此时调用匿名函数打印数字 3，并调用函数 f2，向红色队列中插入一个打印函数；第 3 次 tick，调用红色队列中的打印函数，控制台打印数字 2；第 4 次 tick，调用绿色队列中的打印函数，控制台打印数字 1。<br>关于红色队列和绿色队列，一般称为“宏任务队列（Macro Task Queue）”和“微任务队列（Micro Task Queue）”，不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有当优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。</p>
<p>常见的异步函数优先级如下，从上到下优先级逐层降低：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(Node.js) &gt; </span><br><span class="line">MutationObserver(浏览器)/promise.then(<span class="keyword">catch</span>、finnally)&gt;</span><br><span class="line">setImmediate(IE) &gt; </span><br><span class="line">setTimeout/setIntervalrequestAnimationFrame &gt;</span><br><span class="line">其他 I/O 操作 / 浏览器 DOM 事件</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/27/JSX%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90DOM/">JSX如何变成DOM</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-03-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>入门React的时候，我们了解了神奇的JSX语法，当时的官方是建议使用JSX，作为小白的我当然是乖乖听话。想必现在大家都早已经习惯使用JSX，我们今天来了解一下它是如何成为DOM的。</p>

        <h2 id="JSX的本质"   >
          <a href="#JSX的本质" class="heading-link"><i class="fas fa-link"></i></a>JSX的本质</h2>
      <p>官方描述JSX是JavaScript的扩展语法，它充分具备JavaScript的能力，那么它是怎么做到的呢。这时候我能想到的就是官方霸霸给出的一句话，JSX会被编译成React.createElement(),它会返回一个叫做’React Element’的JS对象。首先编译这个动作，它是由Babel来完成的，我们知道Babel的主要功能是将ECMAScript2015+版本的代码转换成向后兼容的JavaScript语法，从而能运行在当前的浏览器中。其实，JSX也是由Babel来转换为Javascript代码的。<br><img src='/images/Babel转换JSX.png'></p>
<p>我随便找了一段项目里的简单组件的JSX代码放在Babel官网上，它会将其转换成React.createElement的调用。可以看到，所有的JSX标签都被转换成了React.createElement调用，大家明显能感受到，JSX相对而言不仅阅读起来友好，开发起来也比较简单（2333这个比较关键）。小结一下，JSX本质是React.createElement这个JavaScript调用的语法糖，它允许开发者用较熟悉的类HTML标签语法来创建虚拟DOM，提升了开发效率，也降低了学习成本。</p>

        <h2 id="读一读createElement源码"   >
          <a href="#读一读createElement源码" class="heading-link"><i class="fas fa-link"></i></a>读一读createElement源码</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>)</span></span><br></pre></td></tr></table></div></figure>
<p>这个方法有三个入参，type是节点类型，可以是div、span这样的标准HTML标签字符串，也可以是React组件类型；config是一个对象，以键值对的形式存储了组件的属性；children记录的是子节点、子元素对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//propName用于存储元素属性，props用于存储属性的键值对集合</span></span><br><span class="line"><span class="keyword">let</span> propName;</span><br><span class="line"><span class="keyword">const</span> props = &#123; &#125;;</span><br><span class="line"><span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> ref = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> self = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> source = <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// key、ref、self、source 均为 React 元素的属性</span></span><br><span class="line"><span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">  ref = config.ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">  key = <span class="string">''</span> + config.key; </span><br><span class="line">&#125;</span><br><span class="line">self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来将符合的config里的属性放入props中</span></span><br><span class="line"><span class="keyword">for</span> (propsName <span class="keyword">in</span> config) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">    props[propName] = config[propName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//childrenLength是在获取子元素，因此减去的两项是指type和config两个参数占用的长度</span></span><br><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123; </span><br><span class="line">    props.children = children; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123; </span><br><span class="line">  <span class="comment">//处理多个子元素</span></span><br><span class="line">  <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123; </span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将children赋值给props的children属性</span></span><br><span class="line">  props.children = childArray; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//别忘了处理节点的默认属性</span></span><br><span class="line"><span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123; </span><br><span class="line">    <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      props[propName] = defaultProps[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后返回调用ReactElement执行方法，传入处理后的参数</span></span><br><span class="line"><span class="keyword">return</span> ReactElement(</span><br><span class="line">  type,</span><br><span class="line">  key,</span><br><span class="line">  ref,</span><br><span class="line">  self,</span><br><span class="line">  source,</span><br><span class="line">  ReactCurrentOwner.current,</span><br><span class="line">  props,</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>
<p>看完大家会不会有些失望，原来createElement好像也没做啥哈哈哈，它并没有涉及到真实的DOM。其实它只是接受相对简单的参数然后做一次数据处理，最后调用ReactElement来创建元素。那么我们接下来继续康康ReactElement的源码。</p>

        <h2 id="读一读ReactElement源码-认识一下虚拟DOM"   >
          <a href="#读一读ReactElement源码-认识一下虚拟DOM" class="heading-link"><i class="fas fa-link"></i></a>读一读ReactElement源码,认识一下虚拟DOM</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过React.createElement中调用ReactElement方法我们能得知ReactElement的入参有哪些</span></span><br><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置属性赋值</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录创造该元素的组件</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 这里是一些针对 __DEV__ 环境下的处理，不影响理解主要逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>我们可以发现，ReactElement的逻辑也较为简单，它只是按一定规范组装了一个element对象，通过React.createElement最终返回到了开发者。我们平常去打印一个React元素，就会发现它是一个标准的ReactElement对象实例，如图所示。<br><img src='/images/ReactElement元素.png'></p>
<p>这个 ReactElement 对象实例，本质上是以 JavaScript 对象形式存在的对 DOM 的描述，也就是大家常说的虚拟Dom。既然是虚拟的，那它离页面的真实DOM还有一定距离，最终是由ReactDom.render方法来填补的。这个方法可以传入三个参数，需要渲染的元素element，元素挂载的目标容器container也就是真实的DOM节点，以及可选参数回调函数。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/27/%E6%88%91%E7%9C%9F%E7%9A%84%E6%87%82this%E5%90%97/">我真的懂this吗</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-02-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>上篇博客有举一个例子，我们在函数里使用的变量name是属于全局作用域下的，因为JavaScript的作用域是由词法作用域决定的，它在代码阶段就决定好了，跟函数是怎么调用的没有关系。但是在面向对象的语言中，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，JavaScript的作用域机制却对此并不支持，因此我们这时候需要this机制。<br>执行上下文中包含了变量环境、词法环境、外部环境，还有就是this。也就是说，每个执行上下文中都有一个this。我们主要来了解全局执行上下文中的this和函数执行上下文中的this。<br>全局执行上下文中的this，我们可以通过控制台打印一下，最终输出的是window对象，也就是说全局执行上下文中的this是指向window对象的。<br>函数执行上下文中的this，我们在一个函数内部打印this，执行函数打印的也是window对象。这可以理解为是一种缺陷，因为在实际开发中，我们并不希望函数执行上下文中的this指向全局对象，它打破了数据的边界。我们可以设计JavaScript为严格模式，这时候this的指向为怒define。我们可以通过以下几种方式来设置执行上下文中的this。</p>

        <h6 id="1、通过函数的call方法设置"   >
          <a href="#1、通过函数的call方法设置" class="heading-link"><i class="fas fa-link"></i></a>1、通过函数的call方法设置</h6>
      <p>funA.call(objB),funA函数内部的this指向了objB对象,bind、apply也可以用来改变this指向，call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。</p>

        <h5 id="2、通过对象调用方法来设置"   >
          <a href="#2、通过对象调用方法来设置" class="heading-link"><i class="fas fa-link"></i></a>2、通过对象调用方法来设置</h5>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">  name: <span class="string">'able'</span>,</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">objA.printName();</span><br></pre></td></tr></table></div></figure>
<p>当使用对象来调用起内部的一个方法时，该方法的this是指向对象本身的。也可以理解为在执行时将其转化成了objA.printName.call(objA);<br>要注意的是，隐式绑定有一个大坑，它容易丢失！如果我们把objA.printName赋给一个全局对象，然后在全局环境中调用这个对象，它内部的this是指向全局变量window的。我们可以用一个小诀窍来记住，隐式调用的格式一般是XXX.fn();fn()前边如果什么都没有，那它不是隐式绑定。</p>

        <h5 id="3、通过构造函数中设置"   >
          <a href="#3、通过构造函数中设置" class="heading-link"><i class="fas fa-link"></i></a>3、通过构造函数中设置</h5>
      <p>在JavaScript中，构造函对象数只是使用new时被调用的函数，它跟C++不一样，没有类的概念，因此任何一个函数都可以用new来调用，它不属于某个类，也不会实例化出一个类，只能称作是对于函数的构造调用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createA</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> createA (<span class="string">'able'</span>);</span><br></pre></td></tr></table></div></figure>
<p>当执行new createA()我们可以分为以下几步。首先创建一个空对象objA，调用createA.call方法，将objA作为参数，createA的执行上下文创建时，它的this指向来objA对象。然后执行createA函数，此时createA函数执行上下文中的this指向objA对象，最后返回objA对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA  = &#123; &#125;;</span><br><span class="line">createA.call(objA);</span><br><span class="line"><span class="keyword">return</span> objA;</span><br></pre></td></tr></table></div></figure>
<p>这样我们用new构建来一个新的对象，就会将新对象绑定到这个函数的this上。</p>

        <h2 id="绑定优先级"   >
          <a href="#绑定优先级" class="heading-link"><i class="fas fa-link"></i></a>绑定优先级</h2>
      <p>上边有列到好几种绑定规则，new绑定，通过call、apply、bind方式的显式绑定，在某个对象上触发函数调用的隐式绑定，还有默认绑定。它们的优先级为:<br>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>

        <h2 id="this的一些坑"   >
          <a href="#this的一些坑" class="heading-link"><i class="fas fa-link"></i></a>this的一些坑</h2>
      <p>嵌套函数的this不会从外层函数继承，我们来举个例子</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">  name: <span class="string">'able'</span>,</span><br><span class="line">  printThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  innerB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">objA.printThis();</span><br></pre></td></tr></table></div></figure>
<p>这个内部函数innerB中的this，很容易被理解为和其外层printThis函数的this是一致的。但执行后我们会发现，innerB中的this指向的是全局window对象，让人迷惑。<br>早期大家可能会在开发的时候在printThis函数中声明一个_this来保存this，然后在innerB函数中使用_this。当有了箭头函数之后，我们可以用箭头函数的特性来解决这个问题。因为箭头函数不会创建其自身的执行上下文，它的this取决于它的外部函数。关于箭头函数还有几点我们需要注意的，它不可以当作构造函数，不可以使用arguments对象，没有自己的this因此不能用call()等方法改变this指向。</p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>判断this指向流程走一遍：首先我们看函数是否在new中调用；然后是看函数是否通过call,apply调用，或者使用了bind(即硬绑定);、接下来看函数是否在某个上下文对象中调用(隐式绑定)；如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。要注意的是如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。还有如果是箭头函数，箭头函数的this继承的是外层代码块的this。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/23/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">作用域链和闭包</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-01-23</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>上个博客了解了如何通过词法环境和变量环境来查找变量，这其中就涉及到作用域链了，抽象的概念不如来段代码，来，上板栗🌰。</p>

        <h2 id="作用域链"   >
          <a href="#作用域链" class="heading-link"><i class="fas fa-link"></i></a>作用域链</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'zunxingdaming'</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  printName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'moriatry'</span>;</span><br><span class="line">main();</span><br></pre></td></tr></table></div></figure>
<p>那么main函数执行的结果是什么呢？当执行到printName函数内部时，name的值到底到底是从全局执行上下文还是main函数的执行上下文中取呢？可能容易按照调用栈的顺序来查找变量，执行到printName函数内部时，从栈顶到底依次为printName函数执行上下文、main函数执行上下文、全局执行上下文，如果是这样输出结果应该是able，但实际上不是这样，这是为甚呢，让我们进入作用域链的世界探究探究。<br>在每个执行上下文的变量环境里都有一个外部引用，指向外部的执行上下文，可称其为outer。一段代码中使用一个变量时，js引擎会先在当前执行上下文中查找该变量，然后会继续在outer指向的执行上下文中查找。printName函数和main函数的outer都是指向全局上下文，那么上面的栗子在printName函数中要输出name变量，则会取outer指向的全局作用域中寻找，这种查找方式即为链。<br>可能看到这里还会有一些疑问，printName函数是main函数调用的，为啥其outer不是指向main函数呢。这里涉及到一个概念词法作用域，在js的执行过程中，作用域链是由词法作用域来决定的。词法作用域呢表示作用域是由代码中函数声明的位置来决定的，所以说它是静态的，是在代码阶段就定下来了，跟函数是怎么互相调用的没有关系。</p>

        <h2 id="闭包"   >
          <a href="#闭包" class="heading-link"><i class="fas fa-link"></i></a>闭包</h2>
      <p>为了更好的理解闭包，再举个板栗🌰。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerFun = &#123;</span><br><span class="line">      getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;,</span><br><span class="line">setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  name = newName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funA = foo();</span><br><span class="line">funA.setName(<span class="string">'moriaty'</span>);</span><br><span class="line">funA.getName();</span><br><span class="line"><span class="built_in">console</span>.log(funA.getName());</span><br></pre></td></tr></table></div></figure>
<p>innerFun是一个对象，里边包含两个方法，这两个方法中用到了a变量和name变量。根据词法作用域，内部的函数可以访问外部函数foo中的变量。所以当innerFun返回给全局变量funA时，它的两个方法仍可以使用foo函数中的变量。<br>foo函数执行完后，其执行上下文从栈顶弹出，但是其返回的两个方法中使用了变量name和a，因此这两个变量仍保存在内存中。我们可以把它想象成setName和getName两个方法的背包，无法在哪里调用这两个方法，它们都会背着这个foo函数的背包，我们可以把这个背包称为foo函数的闭包。<br>此时此刻，上一个比较规范的闭包定义吧。在js中，根据词法作用域的规则，内部函数可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但内部函数引用外部函数但变量依然保存在内存中，我们称这些变量的集合称之为外部函数的闭包。<br>那么当执行到funA.setName方法中的name = ‘moriaty’时，js引擎会沿着“当前执行上下文-&gt;foo函数闭包-&gt;全局执行上下文”的顺序来查找name变量，可以看下此时的调用栈如下图。所以调用setName时，会修改闭包中name的值。<br><img src='/images/执行funA时调用栈.png' width='300px' height='500px'><br>关于闭包的销毁，如果引用闭包的函数是一个全局变量，那闭包会一直存在到页面关闭，但是如果这个闭包之后不实用的话，会造成内存泄漏。如果引用闭包的函数是个局部变量，等函数销毁后，下次js引擎执行垃圾回收时，判断闭包不再被使用，那么内存会被回收。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/26/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/">变量提升和块级作用域</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-12-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>开始接触JS的时候，想必大家都听过“变量提升”这个词。由于它的存在，一些代码的执行结果可能会出乎我们的意料，其实，这可以算是JS的一个设计缺陷吧。ES6引入了块级作用域和let、const关键字的概念，通过它们能够较好的规避变量提升。但是作为一门语言来说，向下兼容是必要的，所以变量提升的机制我们还是有必要去理解。今天我们尽量去深入底层来分析变量提升的存在原因，以及ES6又是如何去填补这块缺陷的。<br>首先我们需要了解作用域的概念，对于它的定义不同的参考资料都各有各的说法。一个我认为比较好理解的是：作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。它是变量和函数的可访问范围，控制着变量和函数的可见性和生命周期。<br>那么在ES6之前我们知道，只有全局作用域和函数作用域。全局作用域顾名思义就是在代码的任何地方都能访问到里边的对象，而函数作用域呢，就是指变量或者函数是在函数内部定义的，它只能在函数内部被访问。函数执行完后内部定义的变量会被销毁。<br>我们早期学过的C语言、C佳佳、Java等都是有块级作用域这么一个概念的，它是一对大括号包裹的一段代码，比如函数、if语句、for循环语句等。给一些简单等代码吧（全宇宙语言通用）</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">9</span>; i++; i&lt; <span class="number">10</span>) &#123; &#125;;</span><br></pre></td></tr></table></div></figure>
<p>代码块内定义的变量在代码块外部是无法被访问到的，而且上面有提到，代码块中的代码执行完毕后其定义的变量会被销毁。让我们梦回大一，看一段C语言的代码。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* name = <span class="string">"able"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printName();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于C语言有块级作用域，obviously上边的代码打印结果为全局变量的值able。但是如果这段代码是用JS写的呢，结果还会是一样么，我们接着往下看。<br>在ES6之前，Javascript是不支持块级作用域的。可能这门语言设计的初衷就是简约（而不简单），没有考虑块级作用域，所以作用域内部的变量都被统一提升了。导致函数中的变量无论在何处声明，编译时都会被进入到执行上下文的变量环境中，因此在整个函数体内所有地方都能被访问到。<br>我们来用JS来实现上面的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"able"</span>;</span><br><span class="line">printName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">printName();</span><br></pre></td></tr></table></div></figure>
<p>输出结果是什么呢，没想到吧，既不是”able”也不是”moriarty”，是undefined，这是为什么呢？根据之前文章所学，首先创建执行上下文和调用栈，其中printName函数执行上下文的变量环境中name为undefined。执行上下文创建好后，JS引擎执行函数内部代码。函数执行时JS会优先从当前的执行上下文中查找变量，首先执行console打印，那么它会使用函数上下文中的变量值undefined。相信很多人跟为一样，刚开始接触JS的时候会觉得这种结果有些奇怪吧。<br>还有一种情况就是本应被销毁的变量却没有销毁。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了解决变量提升，ES6引入了let和const关键字，使JS也拥有了块级作用域。let和const的用法大家都很清楚了，我们来看看ES6是如果解决变量提升的吧。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>
<p>可以看到输出结果就很符合我们的预期了，这是因为let关键字支持块级作用域，在作用域内声明的变量不会影响外面的变量。JS引擎通过变量环境来实现函数作用域，那么大家肯定会想，ES6即支持变量提升，又如何在函数作用域的基础上来支持块级作用域，它是如何做到的呢？接下来我们结合前面的博客执行上下文相关的知识来一起分析。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBlock</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line">setBlock();</span><br></pre></td></tr></table></div></figure>
<p>执行上面的代码时，首先编译并创建执行上下文，函数内部var声明的变量在编译阶段存放到了变量环境中，let声明的变量，存放到了词法环境中，但是如果是在函数的块级作用域内部let声明的变量并没有存放到词法环境中。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="setBlock函数执行上下文.png"><br>接下来执行代码，此时词法环境中n的值被设置成1。而当进入块级作用域时，作用域块中通过let声明当变量会被存放在词法环境一个单独的区域中，与作用域块外面的变量互不影响，也产生了一个小型栈结构。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C.png" alt="setBlock函数执行.png"><br>栈的底部是函数最外层的变量，进入块级作用域后块内let和const声明的变量会进栈，作用域执行完后该作用域的信息从顶部弹出。而console.log(m)时需要在词法环境和变量环境中来找变量a的值了。首先在词法环境的栈中从顶部向底部查找，如果在某个作用域块中找到了则直接返回，没有找到则继续在变量环境中查找。<br><img src="/images/%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" alt="变量查找过程.png"><br>通过以上我们可以了解到，块级作用域是通过词法环境的小型栈结构来实现的，而JS变量提升的特性是通过变量环境来实现的。想必通过今天的分析，大家对变量提升和块级作用域有了比较清晰的了解啦。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/11/14/JavaScript%E8%B0%83%E7%94%A8%E6%A0%88/">JavaScript调用栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-11-14</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在我们的日常开发中，相信大家应该会遇到过下边这种报错。从字面意思我们能理解为出现了栈溢出，栈占用的空间比分配给它的空间还大，常见的原因是两个函数之间的互相调用，还有就是没有终止条件的递归。栈大家都知道是一种数据结构，那么在这里的栈又是什么呢。那么我们今天来好好了解一下调用栈，概括来说它是用来管理函数调用关系的数据结构。<br>首先我们来说说函数调用，它是指我们声明一个函数并使它运行，具体的写法也就是一个函数名称后边加上一对圆括号。举个板栗</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></div></figure>
<p>在执行函数之前，我们用上一次的学习可以得知，这段代码会生成对应的全局执行上下文，其中的变量环境里包含了声明的函数sayHello和全局变量name、age。接下来开始执行全局代码，这里的sayHello便是一个函数调用，具体会有以下几个步骤。第一步是从全局执行的上下文中拿到声明的函数代码，然后是对这段函数对代码进行编译，创建函数对应的执行上下文和可执行代码，最后执行代码并输出结果。这里我们可以得知，在执行JS代码的时候可能会有多个执行上下文的存在，比如全局执行上下文和函数执行上下文，那么这里我们就能用栈这种数据结构，来管理这些执行上下文。<br>说到栈我们能想到最大的特点就是后进先出了，那么在执行上下文创建好以后，它们便会被压入到栈中，我们称之为调用栈，也叫执行上下文栈。为了更好理解它，我们来写一段比开头那段复杂些的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">by</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byTotal</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">  result = by(b, c);</span><br><span class="line">  <span class="keyword">return</span> a + result + d;</span><br><span class="line">&#125;</span><br><span class="line">byTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>he上边的情况是在一个函数中调用了另一个函数，我们来详细的分析一下过程。<br>首先创建全局上下文并入栈，当前生成的全局上下文的变量环境对象中有变量a、函数by和byTotal。当它入栈后，全局代码被执行，首先6被赋给a，此时调用栈中的情况如下图所示。<br><img src='/images/全局执行上下文.png' width='300px' height='500px'><br>然后是调用byTotal函数，调用时我们首先需要对其进行编译，也是为其创建一个函数执行上下文，并使其进入栈中，如下图所示。<br><img src='/images/byAll函数执行上下文.png' width='300px' height='500px'><br>执行上下文创建好后我们开始执行函数。首先对d进行赋值5，然后我们会执行到by函数，也会创建一个by函数的执行上下文，并使其入账，如下图所示。<br><img src='/images/by函数执行上下文.png' width='300px' height='500px'><br>那么什么时候开始出栈呢，便是by函数的执行结果返回后，它对应的函数执行上下文便会从栈顶弹出啦，此时byAll中的result得到了返回值3，如下图所示。<br><img src='images/函数执行上下文出栈.png' width='300px' height='500px'><br>然后在byAll执行完最后一行并返回值后，它对应的函数执行上下文也会出栈，此时的调用栈中重新回到了最初的亚子，只剩下一个孤零零的全局上下文了。<br>通过上边的步骤，我们可以了解到调用栈的作用了，它可以很直观的给我们展示某个函数在被执行，特别是函数调用较多时，能让我们很清楚各个函数之间的调用关系。<br>那么讲完了原理，它在实践层面上的应用我们一起来看看。在大家用chrome调试的时候，source中debug的位置有一个Call Stack不知道大家还有没有印象呢。我们在source中新建一个代码块(new snippet)，把上边那段demo放入js文件中，打上断点来执行一下这段代码。<br><img src="/images/chrome%E8%B0%83%E8%AF%95%E8%B0%83%E7%94%A8%E6%A0%88.png" alt="chrome调试调用栈.png"><br>我们在by函数中打上断点，右键点击run，可以看到图中的代码执行到断点处暂停了，右侧有Call Stack这一栏可以看到当前调用栈的情况，就跟我上图中画的一致，从底部到顶部依次是anonymous，也就是全局的函数入口，往上是byAll函数，最后顶部是by函数。我们能很直观明了的得知函数之间的调用关系。可能demo比较简单啊，但是在分析较为长的复杂的代码时，它是比较有效的，包括在定位问题时也是一样。如果不习惯打断点的童鞋，我们还有一种方式是使用一个方法——console.trace()，它的效果也是一样的，我们可以在控制台看到其结果。<br><img src="/images/console-trace.png" alt="console-trace.png"></p>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">谁不是，拼了命走到结尾，也许卑微，一生狼狈</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">18</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>前端一岁小白-able.Feng</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>