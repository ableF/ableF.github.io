<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><meta name="renderer" content="webkit"><meta name="format-detection" content="telephone=no"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="black"><link rel="icon" href="/images/icons/favicon-16x16.png?v=2.0.0-rc.0" type="image/png" sizes="16x16"><link rel="icon" href="/images/icons/favicon-32x32.png?v=2.0.0-rc.0" type="image/png" sizes="32x32"><meta name="description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:type" content="website">
<meta property="og:title" content="无名之辈">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="无名之辈">
<meta property="og:description" content="谁不是，拼了命走到生命的结尾">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="前端一岁小白-able.Feng">
<meta name="twitter:card" content="summary"><meta name="keywords" content="前端一岁小白-able.Feng, 无名之辈"><meta name="description" content="谁不是，拼了命走到生命的结尾"><title>无名之辈</title><link ref="canonical" href="http://yoursite.com/index.html"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.12.1/css/all.min.css" type="text/css"><link rel="stylesheet" href="/css/index.css?v=2.0.0-rc.0"><script>var Stun = window.Stun || {};
var CONFIG = {
  root: '/',
  algolia: undefined,
  fontIcon: {"prompt":{"success":"fas fa-check-circle","info":"fas fa-arrow-circle-right","warning":"fas fa-exclamation-circle","error":"fas fa-times-circle"},"copyBtn":"fas fa-copy"},
  sidebar: {"offsetTop":"20px","tocMaxDepth":6},
  header: {"enable":true,"showOnPost":true,"scrollDownIcon":true},
  postWidget: {"endText":true},
  nightMode: {"enable":true},
  back2top: {"enable":true},
  codeblock: {"style":"default","highlight":"light","wordWrap":false},
  reward: false,
  fancybox: false,
  zoomImage: {"gapAside":"20px"},
  galleryWaterfall: undefined,
  lazyload: false,
  pjax: undefined,
  externalLink: {"icon":{"enable":true,"name":"fas fa-external-link-alt"}},
  shortcuts: undefined,
  prompt: {"copyButton":"Copy","copySuccess":"Copy Success","copyError":"Copy Error"},
  sourcePath: {"js":"js","css":"css","images":"images"},
};

window.CONFIG = CONFIG;</script><meta name="generator" content="Hexo 4.2.0"></head><body><div class="container" id="container"><header class="header" id="header"><div class="header-inner"><nav class="header-nav header-nav--fixed"><div class="header-nav-inner"><div class="header-nav-menubtn"><i class="fas fa-bars"></i></div><div class="header-nav-menu"><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/"><span class="header-nav-menu-item__icon"><i class="fas fa-home"></i></span><span class="header-nav-menu-item__text">Home</span></a></div><div class="header-nav-menu-item"><a class="header-nav-menu-item__link" href="/archives/"><span class="header-nav-menu-item__icon"><i class="fas fa-folder-open"></i></span><span class="header-nav-menu-item__text">Archives</span></a></div></div><div class="header-nav-mode"><div class="mode"><div class="mode-track"><span class="mode-track-moon"></span><span class="mode-track-sun"></span></div><div class="mode-thumb"></div></div></div></div></nav><div class="header-banner"><div class="header-banner-info"><div class="header-banner-info__title">无名之辈</div><div class="header-banner-info__subtitle"></div></div><div class="header-banner-arrow"><div class="header-banner-arrow__icon"><i class="fas fa-angle-down"></i></div></div></div></div></header><main class="main" id="main"><div class="main-inner"><div class="content-wrap" id="content-wrap"><div class="content content-home" id="content"><section class="postlist"><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/06/26/es2021%E6%96%B0%E7%89%B9%E6%80%A7/">es2021新特性</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-06-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>ECMAScript 2021 新特性</p>
<p>1 String.prototype.replaceAll()<br>在JavaScript中，replace()方法只替换字符串中的第一个实例。如果我们想替换字符串中的所有匹配项，唯一的办法就使用全局正则表达式。<br>新特性replaceAll()会返回一个新的字符串，字符串中所有的匹配项都会被替换掉。模式可以是字符串或正则表达式，替换的内容可以是字符串或是为每个匹配项执行的函数。</p>
<p>原本的replace()只能替换掉第一个匹配项：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批 "</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replace(<span class="string">"审批"</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// 人事 审批 审批 审批</span></span><br></pre></td></tr></table></div></figure>
<p>如果想要完全匹配替换需要写全局正则表达式：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批"</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replace(<span class="regexp">/审批/g</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">// 人事 人事 人事 人事</span></span><br></pre></td></tr></table></div></figure>
<p>新的replaceAll()特性：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> str = <span class="string">"审批 审批 审批 审批"</span></span><br><span class="line"><span class="keyword">const</span> newStr = str.replaceAll(<span class="string">"审批"</span>, <span class="string">"人事"</span>)</span><br><span class="line"><span class="built_in">console</span>.log(newStr) <span class="comment">//人事 人事 人事 人事</span></span><br></pre></td></tr></table></div></figure>

<p>2 Promise.any<br>ES2020已经通过了Promise的allSettled()方法。ES2021 Promise阵营将有一个新的成员，any()。<br>当Promise列表中的任意一个promise成功resolve则会短路并返回第一个resolve的结果状态， 如果所有的promise均reject，则抛出异常AggregateError，表示所有请求失败。<br>Promise.any()与Promise.race()十分容易混淆，务必注意区分。Promise.race() 一旦某个promise触发了resolve或者reject，就直接返回了该状态的结果。<br>即使Promise在resolve的之前被reject，Promise.any()仍将返回第一个resolve的结果：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(reject(<span class="string">'workflow'</span>), <span class="number">100</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve(<span class="string">'staff'</span>), <span class="number">1000</span>)),</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> setTimeout(resolve(<span class="string">'holiday'</span>), <span class="number">2000</span>))</span><br><span class="line">])</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;value&#125;</span>`</span>)) <span class="comment">// 结果：staff</span></span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err));</span><br></pre></td></tr></table></div></figure>
<p>当所有promise都为reject会抛出异常AggregateError: All promises were rejected：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.any([</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error one'</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error two'</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.reject(<span class="string">'Error three'</span>)</span><br><span class="line">])</span><br><span class="line">    .then(<span class="function">(<span class="params">value</span>) =&gt;</span> <span class="built_in">console</span>.log(<span class="string">`结果：<span class="subst">$&#123;value&#125;</span>`</span>))</span><br><span class="line">    .catch(<span class="function">(<span class="params">err</span>) =&gt;</span> <span class="built_in">console</span>.log(err)); <span class="comment">// AggregateError: All promises were rejected</span></span><br></pre></td></tr></table></div></figure>
<p>3 逻辑运算符和赋值表达式<br>在JavaScript中，有很多赋值操作符和逻辑操作符，在新的草案下，我们可以组合逻辑运算符和赋值运算符。<br>a &amp;&amp;= b 当a值存在时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a &amp;&amp;= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1. a &amp;&amp; (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (a) a = b</span></span><br></pre></td></tr></table></div></figure>
<p>a ||= b 当a值不存在时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a ||= b</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1. a || (a = b)</span></span><br><span class="line"><span class="comment">// 2. if (!a) a = b</span></span><br></pre></td></tr></table></div></figure>
<p>a ??= b 当a值为null或者undefined时，将b变量赋值给a：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br><span class="line"></span><br><span class="line">a = <span class="literal">false</span></span><br><span class="line">a ??= b</span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> navigations = [</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'工作台'</span>,</span><br><span class="line">        path: <span class="string">'/'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        title: <span class="string">'审批'</span>,</span><br><span class="line">        path: <span class="string">'/workflow'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        path: <span class="string">'/setting'</span></span><br><span class="line">    &#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> navigation <span class="keyword">of</span> navigations) &#123;</span><br><span class="line">    page.title ??= <span class="string">'默认'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.table(pages);</span><br><span class="line"></span><br><span class="line"><span class="comment">//   (index)            title                     path</span></span><br><span class="line"><span class="comment">//   0                  "工作台"           "/"</span></span><br><span class="line"><span class="comment">//   1                  "审批"                "/workflow"</span></span><br><span class="line"><span class="comment">//   2                  "默认"                "/setting"</span></span><br></pre></td></tr></table></div></figure>
<p>4 Private Methods &amp; Private Accessors</p>
<p>4.1 私有方法 Private Methods</p>
<p>私有方法只能在定义它的类内部访问，专用方法名称以#开头。由于setType()是私有方法，所以personObj.setType返回undefined，用undefined作函数会引发TypeError。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Private method</span></span><br><span class="line">    ﻿#setType() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Private'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Public method</span></span><br><span class="line">    show() &#123;</span><br><span class="line">        this.#setType();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personObj = <span class="keyword">new</span> Person();</span><br><span class="line">personObj.show(); <span class="comment">// "Private"</span></span><br><span class="line">personObj.setType(); <span class="comment">// TypeError: personObj.setType is not a function</span></span><br></pre></td></tr></table></div></figure>
<p>4.2 私有访问者 Private Accessors</p>
<p>可以通过在函数名称前添加#，使得访问器函数私有。在下面的代码中，name是公共的，可以像普通属性一样读取它, 而age则是私有。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Public accessor</span></span><br><span class="line">    ﻿<span class="keyword">get</span> name() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'able'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> name(value) &#123;&#125;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// Private accessor</span></span><br><span class="line">﻿    <span class="keyword">get</span> #age() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">18</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">set</span> #age(value) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> personObj = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(personObj.name); <span class="comment">// "able"</span></span><br><span class="line"><span class="built_in">console</span>.log(personObj.age); <span class="comment">// undefined</span></span><br></pre></td></tr></table></div></figure>
<p>5 WeakRefs</p>
<p>当我们通过const, let, var创建一个变量时，垃圾收集器GC将永远不会从内存中删除该变量，只要它的引用仍然存在且可访问。而WeakRef对象包含针对对象的弱引用，针对对象的弱引用是不会阻止垃圾收集器GC的回收的，则GC可以在任何时候删除它。</p>
<p>例如有如下场景：<br>跟踪某个对象调用某一特定方法的次数，超过1000条则做对应提示。</p>
<p>如果我们使用Map，虽然可以实现需求，但是会发生内存溢出，因为传递给doSomething()的每个对象都永久保存在map中，并且不会被GC回收。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomething(obj);</span><br><span class="line">    <span class="keyword">let</span> called = map.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用次数已超过1000次'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    map.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>所以，可以通过WeakMap()或者WeakSet()来使用WeakRefs。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wmap = <span class="keyword">new</span> <span class="built_in">WeakMap</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useObject</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    doSomething(obj);</span><br><span class="line">    <span class="keyword">let</span> called = wmap.get(obj) || <span class="number">0</span>;</span><br><span class="line">    called++;</span><br><span class="line">    <span class="keyword">if</span> (called &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'调用次数已超过1000次'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    wmap.set(obj, called);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>因为是弱引用，所以WeakMap、WeakSet的键值对是不可枚举的。WeakSet和WeakMap相似，但是每个对象在WeakSet中只可能出现一次，WeakSet中所有对象都是唯一的。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line"><span class="keyword">let</span> foo = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">ws.add(foo);</span><br><span class="line">ws.add(bar);</span><br><span class="line"></span><br><span class="line">ws.has(foo); <span class="comment">// true</span></span><br><span class="line">ws.has(bar); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">ws.delete(foo); <span class="comment">// 删除foo对象</span></span><br><span class="line"></span><br><span class="line">ws.has(foo); <span class="comment">//false foo已删除</span></span><br><span class="line">ws.has(bar); <span class="comment">// bar仍存在</span></span><br></pre></td></tr></table></div></figure>
<p>WeakSet与Set相比有以下两个区别：<br>WeakSet只能是对象集合，而不能是任何类型的任意值<br>WeakSet弱引用，集合中对象引用为弱引用，如果没有其他对WeakSet对象的引用，则会被GC回收</p>
<p>最后，WeakRef实例有一个方法deref()，返回引用的原始对象，如果原始对象被回收，则返回undefined。下面其在斐波那契数列计算中缓存的妙用：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> setValue = <span class="function">(<span class="params">key, obj</span>) =&gt;</span> &#123;</span><br><span class="line">    cache.set(key, <span class="keyword">new</span> WeakRef(obj));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getValue = <span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> ref = cache.get(key);</span><br><span class="line">    <span class="keyword">if</span> (ref) &#123;</span><br><span class="line">        <span class="keyword">return</span> ref.deref();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> fibonacciCached = <span class="function">(<span class="params">number</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> cached = getValue(number);</span><br><span class="line">    <span class="keyword">if</span> (cached) <span class="keyword">return</span> cached;</span><br><span class="line">    <span class="keyword">const</span> sum = calculateFibonacci(number);</span><br><span class="line">    setValue(number, sum);</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/05/22/TS%E7%B1%BB%E5%9E%8B%E5%85%BC%E5%AE%B9%E6%80%A7/">TS类型兼容性</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-05-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在 TypeScript 里，因为有静态类型检测，我们再也不能像 JavaScript 里那样赋给变量任意类型的值，而能不能把一个类型赋值给其他类型，这是由类型兼容性决定。</p>

        <h2 id="特例"   >
          <a href="#特例" class="heading-link"><i class="fas fa-link"></i></a>特例</h2>
      <p>今天我们看一下 any 等几个特殊类型，它们在类型兼容性这块十分有特色。</p>

        <h3 id="any"   >
          <a href="#any" class="heading-link"><i class="fas fa-link"></i></a>any</h3>
      <p>首先是万金油类型 any，any 类型可以赋值给除了 never 之外任意其他类型，反过来其他类型都可以赋值给 any；换句话说，即 any 兼容除了 never 之外所有类型、同时被所有其他类型兼容。因为 any 太特殊，这里我就不再举例子了，同时再强调一下，Any is 😈，我们要慎用、少用 any。</p>

        <h3 id="never"   >
          <a href="#never" class="heading-link"><i class="fas fa-link"></i></a>never</h3>
      <p>下个特例是 never，它的特性是可以赋值给任何其他类型，但反过来不能被其他任何类型包括 any 在内赋值。如以下示例里我们可以把 never 赋值给 number、函数、对象类型：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> never: never = <span class="function">(<span class="params">(</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">'never'</span>);</span><br><span class="line">  &#125;)();</span><br><span class="line">  <span class="keyword">let</span> a: number = never; <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">let</span> b: <span class="function"><span class="params">()</span> =&gt;</span> any = never; <span class="comment">// ok</span></span><br><span class="line">  <span class="keyword">let</span> c: &#123;&#125; = never; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="unknown"   >
          <a href="#unknown" class="heading-link"><i class="fas fa-link"></i></a>unknown</h3>
      <p>unknown 的特性几乎正好和 never 反过来，我们不能把 unknown 赋值给除了 any 之外其他任何类型；反过来其他类型都可以赋值给 unknown。如以下示例里，会提示 ts(2322) unknown 类型不能赋值给其他类型的错误。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> unknown: unknown;</span><br><span class="line">  <span class="keyword">const</span> a: number = unknown; <span class="comment">// ts(2322)</span></span><br><span class="line">  <span class="keyword">const</span> b: <span class="function"><span class="params">()</span> =&gt;</span> any = unknown; <span class="comment">// ts(2322)</span></span><br><span class="line">  <span class="keyword">const</span> c: &#123;&#125; = unknown; <span class="comment">// ts(2322)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="void、null、undefined"   >
          <a href="#void、null、undefined" class="heading-link"><i class="fas fa-link"></i></a>void、null、undefined</h3>
      <p>三大无用类型的兼容性也是很特别的，比如 void 类型仅可赋值给 any 和 unknown 类型，反过来仅 any、never、undefined 可赋值给 void。此外，在严格模式下，null、undefined 表现出与 void 类似的兼容性，不能赋值给除 any 和 unknown 之外的其他类型，反过来除了 any 和 never 之外其他类型都不可以赋值给 null 或者 undefined。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> thisIsAny: any;</span><br><span class="line">  <span class="keyword">let</span> thisIsNever: never;</span><br><span class="line">  <span class="keyword">let</span> thisIsUnknown: unknown;</span><br><span class="line">  <span class="keyword">let</span> thisIsVoid: <span class="keyword">void</span>;</span><br><span class="line">  <span class="keyword">let</span> thisIsUndefined: <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">let</span> thisIsNull: <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  thisIsAny = thisIsVoid; <span class="comment">// ok</span></span><br><span class="line">  thisIsUnknown = thisIsVoid; <span class="comment">// ok</span></span><br><span class="line">  thisIsVoid = thisIsAny; <span class="comment">// ok</span></span><br><span class="line">  thisIsVoid = thisIsNever; <span class="comment">// ok</span></span><br><span class="line">  thisIsVoid = thisIsUndefined; <span class="comment">// ok</span></span><br><span class="line"></span><br><span class="line">  thisIsAny = thisIsNull; <span class="comment">// ok</span></span><br><span class="line">  thisIsUnknown = thisIsNull; <span class="comment">// ok</span></span><br><span class="line">  thisIsAny = thisIsUndefined; <span class="comment">// ok</span></span><br><span class="line">  thisIsUnknown = thisIsUndefined; <span class="comment">// ok</span></span><br><span class="line">  </span><br><span class="line">  thisIsNull = thisIsAny; <span class="comment">// ok</span></span><br><span class="line">  thisIsNull = thisIsNever; <span class="comment">// ok</span></span><br><span class="line">  thisIsUndefined = thisIsAny; <span class="comment">// ok</span></span><br><span class="line">  thisIsUndefined = thisIsNever; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h3 id="enum"   >
          <a href="#enum" class="heading-link"><i class="fas fa-link"></i></a>enum</h3>
      <p>最后一个特例是 enum 枚举类型，其中数字枚举和数字类型是相互兼容，如以下示例里，我们可以把枚举 A 赋值给数字（number）类型，同时也可以通过数字字面量 1 替代枚举 A。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  enum A &#123;</span><br><span class="line">    one</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> num: number = A.one; <span class="comment">// oklet fun = (param: A) =&gt; void 0;</span></span><br><span class="line">  fun(<span class="number">1</span>); <span class="comment">// ok </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>此外，不同枚举之间是不兼容的，如以下示例里，因为枚举 A 和 B 不兼容，所以都会提示 ts(2322) 类型错误：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  enum A &#123;</span><br><span class="line">    one</span><br><span class="line">  &#125;</span><br><span class="line">  enum B &#123;</span><br><span class="line">    one</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> a: A;</span><br><span class="line">  <span class="keyword">let</span> b: B;</span><br><span class="line">  a = b; <span class="comment">// ts(2322)</span></span><br><span class="line">  b = a; <span class="comment">// ts(2322)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>


        <h2 id="类型兼容性"   >
          <a href="#类型兼容性" class="heading-link"><i class="fas fa-link"></i></a>类型兼容性</h2>
      <p>除去前边提到的所有特例，TypeScript 里类型的兼容性是基于结构化子类型的一般原则进行判定的，我们可以从结构化类型和子类型两个方面来了解这个一般原则。</p>

        <h3 id="子类型"   >
          <a href="#子类型" class="heading-link"><i class="fas fa-link"></i></a>子类型</h3>
      <p>首先我们从子类型角度来看，即所有的子类型与它的父类型兼容，如示例里我们可以把类型是数字字面量类型 one 赋值给数字类型的 num、我们可以把子接口类型的变量 赋值给 Par、我们可以把子类实例 ChildInst 赋值给 ParInst；成员类型兼容它所属的类型集合（其实联合类型和枚举都算是类型集合，我们这里主要说的是联合类型），如示例所示，我们可以把 one 赋值给包含字面类型 1 的联合类型。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> num: number = one; <span class="comment">// okinterface IPar &#123;</span></span><br><span class="line">    name: string;</span><br><span class="line">  &#125;</span><br><span class="line">  interface IChild extends IPar &#123;</span><br><span class="line">    id: number;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> Par: IPar;</span><br><span class="line">  <span class="keyword">let</span> Child: IChild;</span><br><span class="line">  Par = Child; <span class="comment">// okclass CPar &#123;</span></span><br><span class="line">    cname = <span class="string">''</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">CChild</span> <span class="keyword">extends</span> <span class="title">CPar</span> </span>&#123;</span><br><span class="line">    cid = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> ParInst: CPar;</span><br><span class="line">  <span class="keyword">let</span> ChildInst: CChild;</span><br><span class="line">  ParInst = ChildInst; <span class="comment">// ok</span></span><br><span class="line"><span class="keyword">let</span> mixedNum: <span class="number">1</span> | <span class="number">2</span> | <span class="number">3</span> = one; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>举一反三，由子类型组成的联合类型也是可以兼容它们父类型组成的联合类型，如示例所示，因为 IChild 是 IPar 的子类、CChild 是 CPar 的子类，所以 IChild | CChild 也是 IPar | CPar 的子类，进而 ICChild 可以赋值给 ICPar：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ICPar: IPar | CPar;</span><br><span class="line"><span class="keyword">let</span> ICChild: IChild | CChild;</span><br><span class="line">ICPar = ICChild; <span class="comment">// ok</span></span><br></pre></td></tr></table></div></figure>


        <h3 id="结构类型"   >
          <a href="#结构类型" class="heading-link"><i class="fas fa-link"></i></a>结构类型</h3>
      <p>类型兼容性准则另一方面是结构类型，即是说如果两个类型的结构一致，则它们是互相兼容的；比如拥有相同类型的属性、方法的接口类型或者类，则可以互相赋值，如示例所示，因为 类 C1、C2、接口 I1、I2 它们的结构完全一致，所以如示例所示，我们可以把 C2 类的实例 InstC2 赋值给 C1 类的实例 Inst1、把 I2 类型的变量 O2 赋值给 I1 类型的 O1；甚至，如示例所示，可以把 I1 类型的变量 O1 赋值给 C1 类的实例、把 C2 类的示例赋值给 I2 类型的变量 O2：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</span><br><span class="line">    name = <span class="string">'1'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">C2</span> </span>&#123;</span><br><span class="line">    name = <span class="string">'2'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  interface I1 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">  &#125;</span><br><span class="line">  interface I2 &#123;</span><br><span class="line">    name: string;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> InstC1: C1;</span><br><span class="line">  <span class="keyword">let</span> InstC2: C2;</span><br><span class="line">  <span class="keyword">let</span> O1: I1;</span><br><span class="line">  <span class="keyword">let</span> O2: I2;</span><br><span class="line">  InstC1 = InstC2; <span class="comment">// ok</span></span><br><span class="line">  O1 = O2; <span class="comment">// ok</span></span><br><span class="line">  InstC1 = O1; <span class="comment">// ok</span></span><br><span class="line">  O2 = InstC2; <span class="comment">// ok</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/04/24/%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BB%A3%E7%A0%81%E6%B2%A1%E6%9C%89%E6%8C%89%E7%BC%96%E5%86%99%E9%A1%BA%E5%BA%8F%E6%89%A7%E8%A1%8C/">为什么代码没有按编写顺序执行</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-04-24</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>前端工程师算是最幸运的软件工程师，因为从一开始就可以接触到“异步”这种高级特性，比如 DOM 事件、AJAX 请求及定时器；同时也是最不幸的软件工程师，因为入门 JavaScript 的时候就要习惯异步这种高难度的开发方式，异步经常会导致输出的结果与我们的预期不一致。</p>

        <h4 id="异步和同步"   >
          <a href="#异步和同步" class="heading-link"><i class="fas fa-link"></i></a>异步和同步</h4>
      <p>这两个概念大家应该都比较熟悉啦，简单解释一下，要比较同步和异步，可以将调用函数的过程分成两部分：执行操作和返回结果。程序在同步调用函数的时候，会立即执行操作并等待得到返回结果后再继续运行，也就是说同步执行是阻塞的。而异步会将操作和结果在时间上分隔开来，在当下执行操作，在未来某个时刻返回结果，在这个等待返回结果的过程中，程序将继续执行后面的代码。也就是说异步执行是非阻塞的。这里就不举🌰啦。</p>

        <h4 id="异步与回调"   >
          <a href="#异步与回调" class="heading-link"><i class="fas fa-link"></i></a>异步与回调</h4>
      <p>我们经常调用 JavaScript 的异步函数可能会认为：异步操作都采用回调函数的形式。毕竟从浏览器端的 DOM 事件、AJAX 请求、定时器到 Node.js 端的文件读写、多进程，都是采用的回调形式。那么还会有其他case嘛，上🌰。<br>下面是一段简单的代码，定义了一个 JSON 对象 a，然后把它打印到控制台，最后再将对象 a 的 couter.index 属性值自增 1。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  counter: &#123;</span><br><span class="line">    index: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log( a ); <span class="comment">// ?</span></span><br><span class="line">a.counter.index++;</span><br></pre></td></tr></table></div></figure>
<p>我们在控制台里看一下，结果可能和我们的预期不一致，输出了一个JSON 对象：{conter:{index: 2}}。原因在于浏览器在运行代码的时候，把控制台打印这种涉及 I/O 的操作进行了延迟执行。可能有人会推测是不是控制台打印的只是将对象 a 进行了类似“浅拷贝”的操作，否定这种猜想很简单，此时再执行一次自增操作，就会发现被打印的对象值并没有发生变化。<br>既然并非所有异步都回调，那么反过来，是否所有回调函数都是异步执行的呢？答案也是否定的。比如数组原型函数 forEach，它有两个参数，第一个是回调函数，第二个是 this 指向的对象，这里的回调就是同步的。</p>

        <h4 id="异步原理"   >
          <a href="#异步原理" class="heading-link"><i class="fas fa-link"></i></a>异步原理</h4>
      <p>回顾了异步的基础概念，下面就来深入讲解异步的原理。</p>

        <h5 id="事件循环"   >
          <a href="#事件循环" class="heading-link"><i class="fas fa-link"></i></a>事件循环</h5>
      <p>对于大多数语言而言，实现异步会通过启动额外的进程、线程或协程来实现，而我们在前面已经提到过，JavaScript 是单线程的。为什么单线程还能实现异步呢？其实也没有什么特殊的黑魔法，只是把一些操作交给了其他线程处理，然后采用了一种称之为“事件循环”（也称“事件轮询”）的机制来处理返回结果。<br>下面我们用一段简化的代码，来描述事件循环机制。<br>数组 eventLoop 表示事件队列（也有称作“任务队列”），用来存放需要执行的任务事件（可以理解为回调函数），对象 event 变量表示当前需要执行的任务事件。用一个永不停止的 while 循环来表示事件循环，每一次循环称为一个 tick。对每个 tick 而言，如果在队列中有等待事件，那么就会从队列中获取一个事件并执行，这些事件通常是回调函数的形式。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eventLoop = []; <span class="comment">// 事件队列，先进先出</span></span><br><span class="line"><span class="keyword">var</span> event; <span class="comment">// 事件执行成功的回调回调函数</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// 一次tick</span></span><br><span class="line">  <span class="keyword">if</span> (eventLoop.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 队列中取出回调函数</span></span><br><span class="line">    event = eventLoop.shift();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      event();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      reportError(err); </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>那么这个事件队列里的事件是怎么来的呢？以 AJAX 请求为例，当我们发出一个 AJAX 请求时，浏览器会将请求任务分派给网络线程来进行处理，当对应的网络线程拿到返回的数据之后，就会把回调函数插入到事件队列中。setTimeout 和 setInterval 也是同样的道理，当我们执行 setTimeout 的时候并不是直接把回调函数放入事件队列中。它所做的是交给定时器线程来处理，当定时器到时后，再把回调函数放在事件队列中，这样，在未来的某轮 tick 中获取并执行这个回调函数。这么做有一个隐性的问题，如果事件队列中已经有其他事件，那么这个回调就会排队等待。所以说 setTimeout/setInterval 定时器的精度并不高。准确地说，它只能确保回调函数不会在指定的时间间隔之前运行，但可能会在那个时刻运行，也可能在那之后运行，这就要根据事件队列的状态而定。</p>

        <h5 id="事件队列"   >
          <a href="#事件队列" class="heading-link"><i class="fas fa-link"></i></a>事件队列</h5>
      <p>在讲述 setTimeout/setInterval 原理的时候也暴露了事件队列的一个缺陷：事件队列按照先进先出的顺序执行，那么如果队列较长时，排在后面的事件即使较为“紧急”，也得需要等待前面的任务先执行完成。JavaScript 解决这个问题的思路就是：设置多个队列，按照优先级来执行。<br>下面这段代码可以验证 JavaScript 内部拥有优先级不同的 2 个队列，我们暂时称为红色队列和绿色队列，其中红色队列优先级高于绿色队列。这段代码定义了 4 个异步函数 f1、f2、f3、f4，其中：函数 f1 通过定时器 setTimeout 向绿色队列中插入一个控制台打印任务，输出数字 1；函数 f2 通过 Promise 向红色队列中插入一个控制台打印任务，输出数字 2；函数 f3 通过定时器 setTimeout 向绿色队列中插入一个回调函数，该回调函数会调用控制台打印数字 3，并且调用函数 f2；函数 f4 通过 Promise 向红色队列中插入一个回调函数，该回调函数会调用控制台打印数字 4，并且调用函数 f1。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">1</span>), <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="built_in">console</span>.log.bind(<span class="literal">null</span>,<span class="number">2</span>))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f3</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">    f2()</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f4</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br><span class="line">    f1()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">f3()</span><br><span class="line">f4()</span><br></pre></td></tr></table></div></figure>
<p>当调用函数 f3 和函数 f4 之后，绿色队列和红色队列都会被插入一个匿名回调函数。第 1 次 tick，由于红色队列优先级高，所以先执行红色匿名函数，控制台打印数字 4，然后调用函数 f1，向绿色队列中插入一个打印函数；第 2 次 tick，按照先进先出原则，此时调用匿名函数打印数字 3，并调用函数 f2，向红色队列中插入一个打印函数；第 3 次 tick，调用红色队列中的打印函数，控制台打印数字 2；第 4 次 tick，调用绿色队列中的打印函数，控制台打印数字 1。<br>关于红色队列和绿色队列，一般称为“宏任务队列（Macro Task Queue）”和“微任务队列（Micro Task Queue）”，不同队列优先级不同，每次事件循环时会从优先级高的队列中获取事件，只有当优先级高的队列为空时才会从优先级低的队列中获取事件，同级队列之间的事件不存在优先级，只遵循先进先出的原则。</p>
<p>常见的异步函数优先级如下，从上到下优先级逐层降低：</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">process.nextTick(Node.js) &gt; </span><br><span class="line">MutationObserver(浏览器)/promise.then(<span class="keyword">catch</span>、finnally)&gt;</span><br><span class="line">setImmediate(IE) &gt; </span><br><span class="line">setTimeout/setIntervalrequestAnimationFrame &gt;</span><br><span class="line">其他 I/O 操作 / 浏览器 DOM 事件</span><br></pre></td></tr></table></div></figure>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/03/27/JSX%E5%A6%82%E4%BD%95%E5%8F%98%E6%88%90DOM/">JSX如何变成DOM</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-03-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>入门React的时候，我们了解了神奇的JSX语法，当时的官方是建议使用JSX，作为小白的我当然是乖乖听话。想必现在大家都早已经习惯使用JSX，我们今天来了解一下它是如何成为DOM的。</p>

        <h2 id="JSX的本质"   >
          <a href="#JSX的本质" class="heading-link"><i class="fas fa-link"></i></a>JSX的本质</h2>
      <p>官方描述JSX是JavaScript的扩展语法，它充分具备JavaScript的能力，那么它是怎么做到的呢。这时候我能想到的就是官方霸霸给出的一句话，JSX会被编译成React.createElement(),它会返回一个叫做’React Element’的JS对象。首先编译这个动作，它是由Babel来完成的，我们知道Babel的主要功能是将ECMAScript2015+版本的代码转换成向后兼容的JavaScript语法，从而能运行在当前的浏览器中。其实，JSX也是由Babel来转换为Javascript代码的。<br><img src='/images/Babel转换JSX.png'></p>
<p>我随便找了一段项目里的简单组件的JSX代码放在Babel官网上，它会将其转换成React.createElement的调用。可以看到，所有的JSX标签都被转换成了React.createElement调用，大家明显能感受到，JSX相对而言不仅阅读起来友好，开发起来也比较简单（2333这个比较关键）。小结一下，JSX本质是React.createElement这个JavaScript调用的语法糖，它允许开发者用较熟悉的类HTML标签语法来创建虚拟DOM，提升了开发效率，也降低了学习成本。</p>

        <h2 id="读一读createElement源码"   >
          <a href="#读一读createElement源码" class="heading-link"><i class="fas fa-link"></i></a>读一读createElement源码</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, config, children</span>)</span></span><br></pre></td></tr></table></div></figure>
<p>这个方法有三个入参，type是节点类型，可以是div、span这样的标准HTML标签字符串，也可以是React组件类型；config是一个对象，以键值对的形式存储了组件的属性；children记录的是子节点、子元素对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//propName用于存储元素属性，props用于存储属性的键值对集合</span></span><br><span class="line"><span class="keyword">let</span> propName;</span><br><span class="line"><span class="keyword">const</span> props = &#123; &#125;;</span><br><span class="line"><span class="keyword">let</span> key = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> ref = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> self = <span class="literal">null</span>; </span><br><span class="line"><span class="keyword">let</span> source = <span class="literal">null</span>; </span><br><span class="line"><span class="comment">// key、ref、self、source 均为 React 元素的属性</span></span><br><span class="line"><span class="keyword">if</span> (hasValidRef(config)) &#123;</span><br><span class="line">  ref = config.ref;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (hasValidKey(config)) &#123;</span><br><span class="line">  key = <span class="string">''</span> + config.key; </span><br><span class="line">&#125;</span><br><span class="line">self = config.__self === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__self;</span><br><span class="line">source = config.__source === <span class="literal">undefined</span> ? <span class="literal">null</span> : config.__source;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接下来将符合的config里的属性放入props中</span></span><br><span class="line"><span class="keyword">for</span> (propsName <span class="keyword">in</span> config) &#123;</span><br><span class="line">  <span class="keyword">if</span> (hasOwnProperty.call(config, propName) &amp;&amp; !RESERVED_PROPS.hasOwnProperty(propName)) &#123;</span><br><span class="line">    props[propName] = config[propName];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//childrenLength是在获取子元素，因此减去的两项是指type和config两个参数占用的长度</span></span><br><span class="line"><span class="keyword">const</span> childrenLength = <span class="built_in">arguments</span>.length - <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (childrenLength === <span class="number">1</span>) &#123; </span><br><span class="line">    props.children = children; </span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (childrenLength &gt; <span class="number">1</span>) &#123; </span><br><span class="line">  <span class="comment">//处理多个子元素</span></span><br><span class="line">  <span class="keyword">const</span> childArray = <span class="built_in">Array</span>(childrenLength); </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; childrenLength; i++) &#123; </span><br><span class="line">    childArray[i] = <span class="built_in">arguments</span>[i + <span class="number">2</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//将children赋值给props的children属性</span></span><br><span class="line">  props.children = childArray; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">//别忘了处理节点的默认属性</span></span><br><span class="line"><span class="keyword">if</span> (type &amp;&amp; type.defaultProps) &#123;</span><br><span class="line">  <span class="keyword">const</span> defaultProps = type.defaultProps;</span><br><span class="line">  <span class="keyword">for</span> (propName <span class="keyword">in</span> defaultProps) &#123; </span><br><span class="line">    <span class="keyword">if</span> (props[propName] === <span class="literal">undefined</span>) &#123;</span><br><span class="line">      props[propName] = defaultProps[propName];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后返回调用ReactElement执行方法，传入处理后的参数</span></span><br><span class="line"><span class="keyword">return</span> ReactElement(</span><br><span class="line">  type,</span><br><span class="line">  key,</span><br><span class="line">  ref,</span><br><span class="line">  self,</span><br><span class="line">  source,</span><br><span class="line">  ReactCurrentOwner.current,</span><br><span class="line">  props,</span><br><span class="line">);</span><br></pre></td></tr></table></div></figure>
<p>看完大家会不会有些失望，原来createElement好像也没做啥哈哈哈，它并没有涉及到真实的DOM。其实它只是接受相对简单的参数然后做一次数据处理，最后调用ReactElement来创建元素。那么我们接下来继续康康ReactElement的源码。</p>

        <h2 id="读一读ReactElement源码-认识一下虚拟DOM"   >
          <a href="#读一读ReactElement源码-认识一下虚拟DOM" class="heading-link"><i class="fas fa-link"></i></a>读一读ReactElement源码,认识一下虚拟DOM</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过React.createElement中调用ReactElement方法我们能得知ReactElement的入参有哪些</span></span><br><span class="line"><span class="keyword">const</span> ReactElement = <span class="function"><span class="keyword">function</span>(<span class="params">type, key, ref, self, source, owner, props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = &#123;</span><br><span class="line">    <span class="comment">// REACT_ELEMENT_TYPE是一个常量，用来标识该对象是一个ReactElement</span></span><br><span class="line">    $$<span class="keyword">typeof</span>: REACT_ELEMENT_TYPE,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内置属性赋值</span></span><br><span class="line">    type: type,</span><br><span class="line">    key: key,</span><br><span class="line">    ref: ref,</span><br><span class="line">    props: props,</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录创造该元素的组件</span></span><br><span class="line">    _owner: owner,</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// </span></span><br><span class="line">  <span class="keyword">if</span> (__DEV__) &#123;</span><br><span class="line">    <span class="comment">// 这里是一些针对 __DEV__ 环境下的处理，不影响理解主要逻辑</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> element;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></div></figure>
<p>我们可以发现，ReactElement的逻辑也较为简单，它只是按一定规范组装了一个element对象，通过React.createElement最终返回到了开发者。我们平常去打印一个React元素，就会发现它是一个标准的ReactElement对象实例，如图所示。<br><img src='/images/ReactElement元素.png'></p>
<p>这个 ReactElement 对象实例，本质上是以 JavaScript 对象形式存在的对 DOM 的描述，也就是大家常说的虚拟Dom。既然是虚拟的，那它离页面的真实DOM还有一定距离，最终是由ReactDom.render方法来填补的。这个方法可以传入三个参数，需要渲染的元素element，元素挂载的目标容器container也就是真实的DOM节点，以及可选参数回调函数。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/02/27/%E6%88%91%E7%9C%9F%E7%9A%84%E6%87%82this%E5%90%97/">我真的懂this吗</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-02-27</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>上篇博客有举一个例子，我们在函数里使用的变量name是属于全局作用域下的，因为JavaScript的作用域是由词法作用域决定的，它在代码阶段就决定好了，跟函数是怎么调用的没有关系。但是在面向对象的语言中，在对象内部的方法中使用对象内部的属性是一个非常普遍的需求，JavaScript的作用域机制却对此并不支持，因此我们这时候需要this机制。<br>执行上下文中包含了变量环境、词法环境、外部环境，还有就是this。也就是说，每个执行上下文中都有一个this。我们主要来了解全局执行上下文中的this和函数执行上下文中的this。<br>全局执行上下文中的this，我们可以通过控制台打印一下，最终输出的是window对象，也就是说全局执行上下文中的this是指向window对象的。<br>函数执行上下文中的this，我们在一个函数内部打印this，执行函数打印的也是window对象。这可以理解为是一种缺陷，因为在实际开发中，我们并不希望函数执行上下文中的this指向全局对象，它打破了数据的边界。我们可以设计JavaScript为严格模式，这时候this的指向为怒define。我们可以通过以下几种方式来设置执行上下文中的this。</p>

        <h6 id="1、通过函数的call方法设置"   >
          <a href="#1、通过函数的call方法设置" class="heading-link"><i class="fas fa-link"></i></a>1、通过函数的call方法设置</h6>
      <p>funA.call(objB),funA函数内部的this指向了objB对象,bind、apply也可以用来改变this指向，call和apply的作用一样，只是传参方式不同。call和apply都会执行对应的函数，而bind方法不会。</p>

        <h5 id="2、通过对象调用方法来设置"   >
          <a href="#2、通过对象调用方法来设置" class="heading-link"><i class="fas fa-link"></i></a>2、通过对象调用方法来设置</h5>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">  name: <span class="string">'able'</span>,</span><br><span class="line">  printName: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">objA.printName();</span><br></pre></td></tr></table></div></figure>
<p>当使用对象来调用起内部的一个方法时，该方法的this是指向对象本身的。也可以理解为在执行时将其转化成了objA.printName.call(objA);<br>要注意的是，隐式绑定有一个大坑，它容易丢失！如果我们把objA.printName赋给一个全局对象，然后在全局环境中调用这个对象，它内部的this是指向全局变量window的。我们可以用一个小诀窍来记住，隐式调用的格式一般是XXX.fn();fn()前边如果什么都没有，那它不是隐式绑定。</p>

        <h5 id="3、通过构造函数中设置"   >
          <a href="#3、通过构造函数中设置" class="heading-link"><i class="fas fa-link"></i></a>3、通过构造函数中设置</h5>
      <p>在JavaScript中，构造函对象数只是使用new时被调用的函数，它跟C++不一样，没有类的概念，因此任何一个函数都可以用new来调用，它不属于某个类，也不会实例化出一个类，只能称作是对于函数的构造调用。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createA</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> objA = <span class="keyword">new</span> createA (<span class="string">'able'</span>);</span><br></pre></td></tr></table></div></figure>
<p>当执行new createA()我们可以分为以下几步。首先创建一个空对象objA，调用createA.call方法，将objA作为参数，createA的执行上下文创建时，它的this指向来objA对象。然后执行createA函数，此时createA函数执行上下文中的this指向objA对象，最后返回objA对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA  = &#123; &#125;;</span><br><span class="line">createA.call(objA);</span><br><span class="line"><span class="keyword">return</span> objA;</span><br></pre></td></tr></table></div></figure>
<p>这样我们用new构建来一个新的对象，就会将新对象绑定到这个函数的this上。</p>

        <h2 id="绑定优先级"   >
          <a href="#绑定优先级" class="heading-link"><i class="fas fa-link"></i></a>绑定优先级</h2>
      <p>上边有列到好几种绑定规则，new绑定，通过call、apply、bind方式的显式绑定，在某个对象上触发函数调用的隐式绑定，还有默认绑定。它们的优先级为:<br>new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定</p>

        <h2 id="this的一些坑"   >
          <a href="#this的一些坑" class="heading-link"><i class="fas fa-link"></i></a>this的一些坑</h2>
      <p>嵌套函数的this不会从外层函数继承，我们来举个例子</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> objA = &#123;</span><br><span class="line">  name: <span class="string">'able'</span>,</span><br><span class="line">  printThis: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">innerB</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  innerB();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">objA.printThis();</span><br></pre></td></tr></table></div></figure>
<p>这个内部函数innerB中的this，很容易被理解为和其外层printThis函数的this是一致的。但执行后我们会发现，innerB中的this指向的是全局window对象，让人迷惑。<br>早期大家可能会在开发的时候在printThis函数中声明一个_this来保存this，然后在innerB函数中使用_this。当有了箭头函数之后，我们可以用箭头函数的特性来解决这个问题。因为箭头函数不会创建其自身的执行上下文，它的this取决于它的外部函数。关于箭头函数还有几点我们需要注意的，它不可以当作构造函数，不可以使用arguments对象，没有自己的this因此不能用call()等方法改变this指向。</p>

        <h2 id="总结"   >
          <a href="#总结" class="heading-link"><i class="fas fa-link"></i></a>总结</h2>
      <p>判断this指向流程走一遍：首先我们看函数是否在new中调用；然后是看函数是否通过call,apply调用，或者使用了bind(即硬绑定);、接下来看函数是否在某个上下文对象中调用(隐式绑定)；如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。要注意的是如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。还有如果是箭头函数，箭头函数的this继承的是外层代码块的this。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2021/01/23/%E4%BD%9C%E7%94%A8%E5%9F%9F%E9%93%BE%E5%92%8C%E9%97%AD%E5%8C%85/">作用域链和闭包</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2021-01-23</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>上个博客了解了如何通过词法环境和变量环境来查找变量，这其中就涉及到作用域链了，抽象的概念不如来段代码，来，上板栗🌰。</p>

        <h2 id="作用域链"   >
          <a href="#作用域链" class="heading-link"><i class="fas fa-link"></i></a>作用域链</h2>
      <figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">printName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'zunxingdaming'</span>, name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">main</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  printName();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'moriatry'</span>;</span><br><span class="line">main();</span><br></pre></td></tr></table></div></figure>
<p>那么main函数执行的结果是什么呢？当执行到printName函数内部时，name的值到底到底是从全局执行上下文还是main函数的执行上下文中取呢？可能容易按照调用栈的顺序来查找变量，执行到printName函数内部时，从栈顶到底依次为printName函数执行上下文、main函数执行上下文、全局执行上下文，如果是这样输出结果应该是able，但实际上不是这样，这是为甚呢，让我们进入作用域链的世界探究探究。<br>在每个执行上下文的变量环境里都有一个外部引用，指向外部的执行上下文，可称其为outer。一段代码中使用一个变量时，js引擎会先在当前执行上下文中查找该变量，然后会继续在outer指向的执行上下文中查找。printName函数和main函数的outer都是指向全局上下文，那么上面的栗子在printName函数中要输出name变量，则会取outer指向的全局作用域中寻找，这种查找方式即为链。<br>可能看到这里还会有一些疑问，printName函数是main函数调用的，为啥其outer不是指向main函数呢。这里涉及到一个概念词法作用域，在js的执行过程中，作用域链是由词法作用域来决定的。词法作用域呢表示作用域是由代码中函数声明的位置来决定的，所以说它是静态的，是在代码阶段就定下来了，跟函数是怎么互相调用的没有关系。</p>

        <h2 id="闭包"   >
          <a href="#闭包" class="heading-link"><i class="fas fa-link"></i></a>闭包</h2>
      <p>为了更好的理解闭包，再举个板栗🌰。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">var</span> innerFun = &#123;</span><br><span class="line">      getName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> name;</span><br><span class="line">&#125;,</span><br><span class="line">setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(a);</span><br><span class="line">  name = newName;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> innerFun;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> funA = foo();</span><br><span class="line">funA.setName(<span class="string">'moriaty'</span>);</span><br><span class="line">funA.getName();</span><br><span class="line"><span class="built_in">console</span>.log(funA.getName());</span><br></pre></td></tr></table></div></figure>
<p>innerFun是一个对象，里边包含两个方法，这两个方法中用到了a变量和name变量。根据词法作用域，内部的函数可以访问外部函数foo中的变量。所以当innerFun返回给全局变量funA时，它的两个方法仍可以使用foo函数中的变量。<br>foo函数执行完后，其执行上下文从栈顶弹出，但是其返回的两个方法中使用了变量name和a，因此这两个变量仍保存在内存中。我们可以把它想象成setName和getName两个方法的背包，无法在哪里调用这两个方法，它们都会背着这个foo函数的背包，我们可以把这个背包称为foo函数的闭包。<br>此时此刻，上一个比较规范的闭包定义吧。在js中，根据词法作用域的规则，内部函数可以访问外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束，但内部函数引用外部函数但变量依然保存在内存中，我们称这些变量的集合称之为外部函数的闭包。<br>那么当执行到funA.setName方法中的name = ‘moriaty’时，js引擎会沿着“当前执行上下文-&gt;foo函数闭包-&gt;全局执行上下文”的顺序来查找name变量，可以看下此时的调用栈如下图。所以调用setName时，会修改闭包中name的值。<br><img src='/images/执行funA时调用栈.png' width='300px' height='500px'><br>关于闭包的销毁，如果引用闭包的函数是一个全局变量，那闭包会一直存在到页面关闭，但是如果这个闭包之后不实用的话，会造成内存泄漏。如果引用闭包的函数是个局部变量，等函数销毁后，下次js引擎执行垃圾回收时，判断闭包不再被使用，那么内存会被回收。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/12/26/%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87%E5%92%8C%E5%9D%97%E7%BA%A7%E4%BD%9C%E7%94%A8%E5%9F%9F/">变量提升和块级作用域</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-12-26</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>开始接触JS的时候，想必大家都听过“变量提升”这个词。由于它的存在，一些代码的执行结果可能会出乎我们的意料，其实，这可以算是JS的一个设计缺陷吧。ES6引入了块级作用域和let、const关键字的概念，通过它们能够较好的规避变量提升。但是作为一门语言来说，向下兼容是必要的，所以变量提升的机制我们还是有必要去理解。今天我们尽量去深入底层来分析变量提升的存在原因，以及ES6又是如何去填补这块缺陷的。<br>首先我们需要了解作用域的概念，对于它的定义不同的参考资料都各有各的说法。一个我认为比较好理解的是：作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。它是变量和函数的可访问范围，控制着变量和函数的可见性和生命周期。<br>那么在ES6之前我们知道，只有全局作用域和函数作用域。全局作用域顾名思义就是在代码的任何地方都能访问到里边的对象，而函数作用域呢，就是指变量或者函数是在函数内部定义的，它只能在函数内部被访问。函数执行完后内部定义的变量会被销毁。<br>我们早期学过的C语言、C佳佳、Java等都是有块级作用域这么一个概念的，它是一对大括号包裹的一段代码，比如函数、if语句、for循环语句等。给一些简单等代码吧（全宇宙语言通用）</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123; &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">9</span>; i++; i&lt; <span class="number">10</span>) &#123; &#125;;</span><br></pre></td></tr></table></div></figure>
<p>代码块内定义的变量在代码块外部是无法被访问到的，而且上面有提到，代码块中的代码执行完毕后其定义的变量会被销毁。让我们梦回大一，看一段C语言的代码。</p>
<figure class="highlight c"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* name = <span class="string">"able"</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%s \n"</span>, name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">char</span>* name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  printName();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>由于C语言有块级作用域，obviously上边的代码打印结果为全局变量的值able。但是如果这段代码是用JS写的呢，结果还会是一样么，我们接着往下看。<br>在ES6之前，Javascript是不支持块级作用域的。可能这门语言设计的初衷就是简约（而不简单），没有考虑块级作用域，所以作用域内部的变量都被统一提升了。导致函数中的变量无论在何处声明，编译时都会被进入到执行上下文的变量环境中，因此在整个函数体内所有地方都能被访问到。<br>我们来用JS来实现上面的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"able"</span>;</span><br><span class="line">printName = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(name);</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">"moriarty"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line">&#125;</span><br><span class="line">printName();</span><br></pre></td></tr></table></div></figure>
<p>输出结果是什么呢，没想到吧，既不是”able”也不是”moriarty”，是undefined，这是为什么呢？根据之前文章所学，首先创建执行上下文和调用栈，其中printName函数执行上下文的变量环境中name为undefined。执行上下文创建好后，JS引擎执行函数内部代码。函数执行时JS会优先从当前的执行上下文中查找变量，首先执行console打印，那么它会使用函数上下文中的变量值undefined。相信很多人跟为一样，刚开始接触JS的时候会觉得这种结果有些奇怪吧。<br>还有一种情况就是本应被销毁的变量却没有销毁。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">S</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>为了解决变量提升，ES6引入了let和const关键字，使JS也拥有了块级作用域。let和const的用法大家都很清楚了，我们来看看ES6是如果解决变量提升的吧。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(a); <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">test();</span><br></pre></td></tr></table></div></figure>
<p>可以看到输出结果就很符合我们的预期了，这是因为let关键字支持块级作用域，在作用域内声明的变量不会影响外面的变量。JS引擎通过变量环境来实现函数作用域，那么大家肯定会想，ES6即支持变量提升，又如何在函数作用域的基础上来支持块级作用域，它是如何做到的呢？接下来我们结合前面的博客执行上下文相关的知识来一起分析。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setBlock</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> m = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">1</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">let</span> p = <span class="number">4</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(m);</span><br><span class="line">    <span class="built_in">console</span>.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n);</span><br><span class="line">  <span class="built_in">console</span>.log(o);</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line">setBlock();</span><br></pre></td></tr></table></div></figure>
<p>执行上面的代码时，首先编译并创建执行上下文，函数内部var声明的变量在编译阶段存放到了变量环境中，let声明的变量，存放到了词法环境中，但是如果是在函数的块级作用域内部let声明的变量并没有存放到词法环境中。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87.png" alt="setBlock函数执行上下文.png"><br>接下来执行代码，此时词法环境中n的值被设置成1。而当进入块级作用域时，作用域块中通过let声明当变量会被存放在词法环境一个单独的区域中，与作用域块外面的变量互不影响，也产生了一个小型栈结构。<br><img src="/images/setBlock%E5%87%BD%E6%95%B0%E6%89%A7%E8%A1%8C.png" alt="setBlock函数执行.png"><br>栈的底部是函数最外层的变量，进入块级作用域后块内let和const声明的变量会进栈，作用域执行完后该作用域的信息从顶部弹出。而console.log(m)时需要在词法环境和变量环境中来找变量a的值了。首先在词法环境的栈中从顶部向底部查找，如果在某个作用域块中找到了则直接返回，没有找到则继续在变量环境中查找。<br><img src="/images/%E5%8F%98%E9%87%8F%E6%9F%A5%E6%89%BE%E8%BF%87%E7%A8%8B.png" alt="变量查找过程.png"><br>通过以上我们可以了解到，块级作用域是通过词法环境的小型栈结构来实现的，而JS变量提升的特性是通过变量环境来实现的。想必通过今天的分析，大家对变量提升和块级作用域有了比较清晰的了解啦。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/11/14/JavaScript%E8%B0%83%E7%94%A8%E6%A0%88/">JavaScript调用栈</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-11-14</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>在我们的日常开发中，相信大家应该会遇到过下边这种报错。从字面意思我们能理解为出现了栈溢出，栈占用的空间比分配给它的空间还大，常见的原因是两个函数之间的互相调用，还有就是没有终止条件的递归。栈大家都知道是一种数据结构，那么在这里的栈又是什么呢。那么我们今天来好好了解一下调用栈，概括来说它是用来管理函数调用关系的数据结构。<br>首先我们来说说函数调用，它是指我们声明一个函数并使它运行，具体的写法也就是一个函数名称后边加上一对圆括号。举个板栗</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> age = <span class="number">18</span>;</span><br><span class="line"><span class="keyword">return</span> name+age;</span><br><span class="line">&#125;</span><br><span class="line">sayHello();</span><br></pre></td></tr></table></div></figure>
<p>在执行函数之前，我们用上一次的学习可以得知，这段代码会生成对应的全局执行上下文，其中的变量环境里包含了声明的函数sayHello和全局变量name、age。接下来开始执行全局代码，这里的sayHello便是一个函数调用，具体会有以下几个步骤。第一步是从全局执行的上下文中拿到声明的函数代码，然后是对这段函数对代码进行编译，创建函数对应的执行上下文和可执行代码，最后执行代码并输出结果。这里我们可以得知，在执行JS代码的时候可能会有多个执行上下文的存在，比如全局执行上下文和函数执行上下文，那么这里我们就能用栈这种数据结构，来管理这些执行上下文。<br>说到栈我们能想到最大的特点就是后进先出了，那么在执行上下文创建好以后，它们便会被压入到栈中，我们称之为调用栈，也叫执行上下文栈。为了更好理解它，我们来写一段比开头那段复杂些的代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">by</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> b+c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">byTotal</span>(<span class="params">b, c</span>) </span>&#123;</span><br><span class="line"> <span class="keyword">var</span> d = <span class="number">5</span>;</span><br><span class="line">  result = by(b, c);</span><br><span class="line">  <span class="keyword">return</span> a + result + d;</span><br><span class="line">&#125;</span><br><span class="line">byTotal(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>he上边的情况是在一个函数中调用了另一个函数，我们来详细的分析一下过程。<br>首先创建全局上下文并入栈，当前生成的全局上下文的变量环境对象中有变量a、函数by和byTotal。当它入栈后，全局代码被执行，首先6被赋给a，此时调用栈中的情况如下图所示。<br><img src='/images/全局执行上下文.png' width='300px' height='500px'><br>然后是调用byTotal函数，调用时我们首先需要对其进行编译，也是为其创建一个函数执行上下文，并使其进入栈中，如下图所示。<br><img src='/images/byAll函数执行上下文.png' width='300px' height='500px'><br>执行上下文创建好后我们开始执行函数。首先对d进行赋值5，然后我们会执行到by函数，也会创建一个by函数的执行上下文，并使其入账，如下图所示。<br><img src='/images/by函数执行上下文.png' width='300px' height='500px'><br>那么什么时候开始出栈呢，便是by函数的执行结果返回后，它对应的函数执行上下文便会从栈顶弹出啦，此时byAll中的result得到了返回值3，如下图所示。<br><img src='images/函数执行上下文出栈.png' width='300px' height='500px'><br>然后在byAll执行完最后一行并返回值后，它对应的函数执行上下文也会出栈，此时的调用栈中重新回到了最初的亚子，只剩下一个孤零零的全局上下文了。<br>通过上边的步骤，我们可以了解到调用栈的作用了，它可以很直观的给我们展示某个函数在被执行，特别是函数调用较多时，能让我们很清楚各个函数之间的调用关系。<br>那么讲完了原理，它在实践层面上的应用我们一起来看看。在大家用chrome调试的时候，source中debug的位置有一个Call Stack不知道大家还有没有印象呢。我们在source中新建一个代码块(new snippet)，把上边那段demo放入js文件中，打上断点来执行一下这段代码。<br><img src="/images/chrome%E8%B0%83%E8%AF%95%E8%B0%83%E7%94%A8%E6%A0%88.png" alt="chrome调试调用栈.png"><br>我们在by函数中打上断点，右键点击run，可以看到图中的代码执行到断点处暂停了，右侧有Call Stack这一栏可以看到当前调用栈的情况，就跟我上图中画的一致，从底部到顶部依次是anonymous，也就是全局的函数入口，往上是byAll函数，最后顶部是by函数。我们能很直观明了的得知函数之间的调用关系。可能demo比较简单啊，但是在分析较为长的复杂的代码时，它是比较有效的，包括在定位问题时也是一样。如果不习惯打断点的童鞋，我们还有一种方式是使用一个方法——console.trace()，它的效果也是一样的，我们可以在控制台看到其结果。<br><img src="/images/console-trace.png" alt="console-trace.png"></p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/10/17/JavaScript%E4%BB%A3%E7%A0%81%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/">JavaScript代码的执行顺序</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-10-17</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>今天我们来研究一下Javascript的执行顺序，了解它是怎么如何运行的。<br>首先我们来看一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行函数showName'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
<p>Javascript是按顺序执行的，那么看上去在执行到第一行的时候函数showName并没有定义，那么它是不是会报错呢。想必大家应该都知道,它的结果其实是执行函数showName;name undefined;<br>那么通过上边的执行结果，我们可以认识到，函数或者变量可以在它被定义之前使用。对于变量而言，如果它在执行过程中未声明，那么js执行会报错。如果在一个变量定义之前使用它，不会报错，但是该变量的值是undefined。如果在一个函数定义之前执行它，不会报错，而且函数能正常执行。<br>那可能就会产生一些疑问了，为啥子变量和函数能在定义之前使用呢，js不是想象中一行一行执行的么。都是提前使用，为何函数能正常执行，变量值却是undefined。我们来一步一步分析。<br>首先我们了解一下js中的声明和赋值。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'able'</span>;</span><br><span class="line"><span class="comment">//这段代码可以分为两部分</span></span><br><span class="line"><span class="keyword">var</span> name  <span class="comment">//声明部分</span></span><br><span class="line">name = <span class="string">'able'</span>; <span class="comment">//执行部分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hahhahaa'</span>);</span><br><span class="line">&#125;<span class="comment">//完整的函数声明，不涉及到赋值</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> showName  <span class="comment">//声明部分</span></span><br><span class="line">showName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'wowowow'</span>);</span><br><span class="line">&#125; <span class="comment">//赋值部分</span></span><br></pre></td></tr></table></div></figure>
<p>了解声明和赋值之后，，我们先来聊聊变量提升。<br>变量提升呢，它是指在Javascript代码的执行过程中，JS引擎把变量的声明部分和函数的声明部分提升到代码开头的‘行为’。变量被提升后，会给变量设置默认值‘undefined’。下面我们用代码来模拟一下变量提升。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//变量提升部分</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="literal">undefined</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'showName被调用‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//可执行代码部分</span></span><br><span class="line"><span class="string">showName();</span></span><br><span class="line"><span class="string">console.log('</span>name<span class="string">', name);</span></span><br><span class="line"><span class="string">name = '</span>able<span class="string">';</span></span><br></pre></td></tr></table></div></figure>
<p>可以发现，它的执行结果和我们最开始的代码是一毛一样的。那么我们也就理解了为啥子可以在定义之前使用函数或者变量的原因了——函数和变量在执行之前都提升到了代码开头。<br>从字面上来看，变量提升意味着变量和函数的声明会移动到代码的开头，就像我们上边模拟的那样，但事实上，这可能不太准确，变量和函数声明在代码中的位置是不会被改变的，而是在编译阶段会被JS引擎放入到内存中。这里又涉及到JS的执行流程了，一段JS代码在执行之前需要被引擎编译，编译完成后才会进入执行阶段。<br>一段代码在经过编译后，会生成两部分内容：执行上下文和可执行代码。所谓执行上下文呢，它是指JS执行一段代码时的运行环境。比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的this、变量、对象以及函数等。在执行上下文中存在一个变量环境的对象，它里边保存了变量提升的内容，最开始我们研究的那段代码中，变量name和函数showName，都保存在该对象中。我们结合代码来分析一下如何生成变量环境对象。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">showName();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'name'</span>, name);</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'ableF'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'安排name‘);</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></div></figure>
<p>第一行第二行不是声明操作，所以引擎不会做任何处理。第三行有var声明，因此引擎将在环境对象中创建一个名为name的属性，并使用undefined对其初始化。第四行，引擎发现了一个通过function定义的函数，它将函数存储到堆中，并在环境变量中创建了一个showName的属性，然后将该属性值指向堆中函数的位置，这样就生成了变量环境对象。<br>我们可以用一张图来形象滴展示Js的执行流程。<br><img src="/images/Js%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6.jpg" alt="Js执行机制.jpg"><br>那么在有了执行上下文和可执行代码后，我们就可以进入执行阶段了。当执行showName函数时，JS引擎便在变量环境对象中查找该函数，由于变量环境对象中存在该函数的引用，所以JS引擎便开始执行该函数，并且输出‘执行函数showName‘的结果；接下来打印name信息，JS引擎在变量环境对象中查找该对象，由于变量环境中存在name变量且值为undefined，因此输出undefined。接下来把‘able’赋值给name变量，赋值后变量环境中的name属性值改为‘able’。<br>那么如果在代码中出现相同的变量或者函数会发生什么呢，我们来看下面一段代码。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">geName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'able'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getName</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'moriaty'</span>);</span><br><span class="line">&#125;</span><br><span class="line">getName();</span><br></pre></td></tr></table></div></figure>
<p>我们来分析一下它的完整执行流程。首先是编译阶段，遇到了第一个getName函数，会把该函数放到变量环境中。接下来是第二个getName函数，继续存放到变量环境中，但是变量环境中已经有一个getName了，此时第二个会将第一个覆盖。那么可想而知，在执行阶段的时候，两个getName函数的执行都调用的是第二个函数。<br>总结<br>JavaScript的执行机制，先编译，再执行。在编译阶段，变量和函数会被存放到变量环境中，变量的默认值会被设置为undefined；在代码执行阶段，JavaScript引擎会从变量环境中去查找自定义的变量和函数。并且如果在编译阶段如果存在两个相同的函数，那么最终存放在变量环境中的是最后定义的那个，因为它的逻辑是后定义的会覆盖先定义的。</p>
</div></div></article><article class="postlist-item post"><header class="post-header"><h1 class="post-title"><a class="post-title__link" href="/2020/08/22/%E6%89%8B%E5%86%99Promise/">手写Promise</a></h1><div class="post-meta"><span class="post-meta-item post-meta-item--createtime"><span class="post-meta-item__icon"><i class="far fa-calendar-plus"></i></span><span class="post-meta-item__info">Created</span><span class="post-meta-item__value">2020-08-22</span></span></div></header><div class="post-body"><div class="post-excerpt"><p>说到异步编程，大家应该会想到Promise。想必对它对典型的认知应该就是——解决了回调地狱的问题，通过链式调用（不停的.then .then）的方式来避免大量嵌套。对于我个人而言，在使用Promise的过程中还是难免出现一些问题，感觉仍停留在稀里糊涂用的这么一个阶段。今天我想通过实现一个Promise来彻底搞懂其原理。<br>Promise我们可以称之为一个容器，它里边保存了一个异步操作的最终结果。这里有一个<span class="exturl"><a class="exturl__link"   href="https://promisesaplus.com/"  target="_blank" rel="noopener">Promises/A+规范</a><span class="exturl__icon"><i class="fas fa-external-link-alt"></i></span></span>,我们可以按照其中的描述来一步一步的实现一个符合要求的Promise。<br>Promise有三个状态，等待、成功和失败，默认是等待状态。并且一旦成功或者失败了状态就不能改变了。<br>resolve接收一个函数作为参数，我们称之为excutor，它是一个执行器，会立即执行。它有两个参数resolve和reject，分别代表成功和失败。resolve代表的是成功，它会接收一个参数value，状态改变为fulfilled。reject代表的是失败，接收参数reason，状态改变为rejected。这里要注意的是，状态变为成功或者失败后不能再次被更改，如果new Promise的时候throw new Error报错也会变成失败态。<br>每个Promise应该有自己的三个状态，因此我们将它放在构造函数里。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PENDING = <span class="string">'PENDING'</span>;</span><br><span class="line"><span class="keyword">const</span> RESOLVED = <span class="string">'RESOLVED'</span>;</span><br><span class="line"><span class="keyword">const</span> REJECTED = <span class="string">'REJECTED'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Promise</span></span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(executor)&#123;</span><br><span class="line">    <span class="keyword">this</span>.status = PENDING;<span class="comment">//默认是PENDING状态</span></span><br><span class="line">    <span class="keyword">this</span>.value = <span class="literal">undefined</span>;<span class="comment">//成功</span></span><br><span class="line">    <span class="keyword">this</span>.error = <span class="literal">undefined</span>;<span class="comment">//失败</span></span><br><span class="line">    <span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING)<span class="comment">//状态为PENDING时才能改变 &#123;</span></span><br><span class="line">        <span class="keyword">this</span>.status = RESOLVED;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">        <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">        <span class="comment">// 储存失败信息</span></span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">      executor(resolve, reject);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      reject(e);<span class="comment">//执行器执行时内部可能报错</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>每个promise实例都有一个then方法，可以传入两个参数，onFulfilled和onRejected。如果当前状态成功我们调用onfFlfilled，失败调用onRejected.</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">then(onFulfilled,onRejected) &#123;</span><br><span class="line">   <span class="comment">// 状态为fulfilled，执行onFulfilled，传入成功的值</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">     onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">   &#125;;</span><br><span class="line">   <span class="comment">// 状态为rejected，执行onRejected，传入失败的原因</span></span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">this</span>.state === REJECTED) &#123;</span><br><span class="line">     onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">   &#125;;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>当resolve在setTomeout里运行的时候，上边的写法就不能满足要求啦。我们可以采取发布订阅的思想，现将要执行的方法存到数组里，当状态改变后再执行对应的方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> resolve = <span class="function"><span class="params">value</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.state === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.state = RESOLVED;</span><br><span class="line">    <span class="keyword">this</span>.value = value;</span><br><span class="line">    <span class="keyword">this</span>.onResolvedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> reject = <span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">    <span class="keyword">this</span>.status = REJECTED;</span><br><span class="line">    <span class="keyword">this</span>.error = reason;</span><br><span class="line">    <span class="keyword">this</span>.onRejectedCallbacks.forEach(<span class="function"><span class="params">fn</span>=&gt;</span>fn());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">then(onFulfilled, onRejected) &#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.status === PENDING) &#123;</span><br><span class="line">  <span class="keyword">this</span>.onResolvedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">this</span>.onRejectedCallbacks.push(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">    onRejected(<span class="keyword">this</span>.error);</span><br><span class="line">  &#125;)</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>我们需要判断then中传递函数的返回结果。当返回结果是promise时，则采用其状态。如果不是promise。将结果传递下去即可。Promise通过链式调用来解决回调地狱，也就是在第一个then里返回里一个Promise。我们可以在then里面返回一个新的promise,称为promise2。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> promise2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>)=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.status === RESOLVED) &#123;</span><br><span class="line">    <span class="keyword">let</span> x = onFulfilled(<span class="keyword">this</span>.value);</span><br><span class="line">    <span class="comment">// 当x为普通值时，通过resolve保存值。如果是promise则要调用then。我们可以通过一个公共方法来解析x的值和promise2的关系。这里要注意promise必须声明完后才能传入resolvePromise方法，我们可以用setTimeout宏任务做延迟，可以保证得到的是声明后的promise2</span></span><br><span class="line">    resolvePromise(promise2, x, resolve, reject);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></div></figure>

<p>接下来我们来实现resolvePromise这个方法。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolvePromise</span>(<span class="params">promise2, x, resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//首先它的核心功能是判断x的值是不是resolve。而且它的写法要兼容所有的promise情况</span></span><br><span class="line">   <span class="comment">// 如果promise2和x链接的是同一个对象，则报错。比如let promise2 = p.then(() =&gt; &#123; return promise2 &#125;)</span></span><br><span class="line">   <span class="keyword">if</span>(x === promise2)&#123;</span><br><span class="line">     <span class="comment">// reject报错</span></span><br><span class="line">     <span class="keyword">return</span> reject(<span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'循环引用啦'</span>));</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 防止多次调用</span></span><br><span class="line">   <span class="keyword">let</span> called;</span><br><span class="line">   <span class="keyword">if</span> (x != <span class="literal">null</span> &amp;&amp; (<span class="keyword">typeof</span> x === <span class="string">'object'</span> || <span class="keyword">typeof</span> x === <span class="string">'function'</span>)) &#123;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">       <span class="comment">// A+规定，声明then = x的then方法</span></span><br><span class="line">       <span class="keyword">let</span> then = x.then;</span><br><span class="line">       <span class="comment">// 如果then是函数, 可以默认认为是promise了</span></span><br><span class="line">       <span class="keyword">if</span> (<span class="keyword">typeof</span> then === <span class="string">'function'</span>) &#123; </span><br><span class="line">         <span class="comment">//y可能还是一个promise，直到解析出的结果是一个普通值</span></span><br><span class="line">         then.call(x, y =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           resolvePromise(promise2, y, resolve, reject);</span><br><span class="line">         &#125;, err =&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">           called = <span class="literal">true</span>;</span><br><span class="line">           reject(err);<span class="comment">// 采用失败结果向下传递</span></span><br><span class="line">         &#125;)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         resolve(x); <span class="comment">// 说明x是普通对象，直接成功即可</span></span><br><span class="line">       &#125;</span><br><span class="line">     &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">       <span class="comment">//防止多次调用成功和失败</span></span><br><span class="line">       <span class="keyword">if</span> (called) <span class="keyword">return</span>;</span><br><span class="line">       called = <span class="literal">true</span>;</span><br><span class="line">       reject(e); </span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     resolve(x);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></div></figure>

<p>onFulfilled和onRejected均为可选参数。<br>onFulfilled返回一个普通的值，成功时直接等于 data =&gt; data<br>onRejected返回一个普通的值，失败时如果直接等于 data =&gt; data，则会跑到下一个then中的onFulfilled中，所以直接扔出一个错误</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">onFulfilled = <span class="keyword">typeof</span> onFulfilled === <span class="string">'function'</span> ? onFulfilled : <span class="function"><span class="params">data</span> =&gt;</span> data;</span><br><span class="line"><span class="comment">// onRejected如果不是函数，就忽略onRejected，直接扔出错误</span></span><br><span class="line">onRejected = <span class="keyword">typeof</span> onRejected === <span class="string">'function'</span> ? onRejected : <span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> err &#125;;</span><br></pre></td></tr></table></div></figure>

<p>实现了Promise，那么它的all方法和race方法相对来说就比较好实现了。<br>Promise.all()方法用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br>只有传入所有实例的状态都变成fulfilled，新的promises的状态才会变成fulfilled，此时每个实例的返回值组成一个数组，传递给promises的回调函数。<br>只要之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给整个promises的回调函数。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all = <span class="function"><span class="keyword">function</span> (<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//promises是一个promise的数组</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">let</span> arr = []; <span class="comment">//arr是最终返回值的结果</span></span><br><span class="line">      <span class="keyword">let</span> successCount = <span class="number">0</span>; <span class="comment">// 表示成功了多少次</span></span><br><span class="line">      <span class="function"><span class="keyword">function</span> <span class="title">processData</span>(<span class="params">index, data</span>) </span>&#123;</span><br><span class="line">          arr[index] = data;</span><br><span class="line">          successCount++;</span><br><span class="line">          <span class="keyword">if</span> (successCount === promises.length) &#123;</span><br><span class="line">              resolve(arr);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; promises.length; i++) &#123;</span><br><span class="line">          promises[i].then(<span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</span><br><span class="line">              processData(i, data)</span><br><span class="line">          &#125;, reject)</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>

<p>Promise.race也是将多个Promise实例包装成一个新的实例，只要有其中一个实例改变状态那么整个实例状态改变并停止执行。</p>
<figure class="highlight js"><div class="table-container"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.race = <span class="function"><span class="keyword">function</span>(<span class="params">promises</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> len = promises.length;</span><br><span class="line">    <span class="keyword">if</span>(len === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(promise[i]).then(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">        resolve(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">        reject(err);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></div></figure>
</div></div></article></section><nav class="paginator"><div class="paginator-inner"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fas fa-angle-right"></i></a></div></nav></div></div><div class="sidebar-wrap" id="sidebar-wrap"><aside class="sidebar" id="sidebar"><section class="sidebar-toc hide"></section><!-- ov = overview--><section class="sidebar-ov"><div class="sidebar-ov-author"><div class="sidebar-ov-author__avatar"><img class="sidebar-ov-author__avatar_img" src="/images/icons/avatar.jpeg" alt="avatar"></div><p class="sidebar-ov-author__text">谁不是，拼了命走到结尾，也许卑微，一生狼狈</p></div><div class="sidebar-ov-state"><a class="sidebar-ov-state-item sidebar-ov-state-item--posts" href="/archives/"><div class="sidebar-ov-state-item__count">16</div><div class="sidebar-ov-state-item__name">Archives</div></a></div><div class="sidebar-ov-cc"><a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.en" target="_blank" rel="noopener" data-popover="Creative Commons" data-popover-pos="up"><img src="/images/cc-by-nc-sa.svg"></a></div></section></aside></div><div class="clearfix"></div></div></main><footer class="footer" id="footer"><div class="footer-inner"><div><span>Copyright © 2021</span><span class="footer__icon"><i class="fas fa-heart"></i></span><span>前端一岁小白-able.Feng</span></div><div><span>Powered by <a href="http://hexo.io/" title="Hexo" target="_blank" rel="noopener">Hexo</a></span><span> v4.2.0</span><span class="footer__devider">|</span><span>Theme - <a href="https://github.com/liuyib/hexo-theme-stun/" title="Stun" target="_blank" rel="noopener">Stun</a></span><span> v2.0.0-rc.0</span></div></div></footer><div class="loading-bar" id="loading-bar"><div class="loading-bar__progress"></div></div><div class="back2top" id="back2top"><span class="back2top__icon"><i class="fas fa-rocket"></i></span></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@v3.4.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.min.js"></script><script src="https://cdn.jsdelivr.net/npm/velocity-animate@1.5.2/velocity.ui.min.js"></script><script src="/js/utils.js?v=2.0.0-rc.0"></script><script src="/js/stun-boot.js?v=2.0.0-rc.0"></script><script src="/js/scroll.js?v=2.0.0-rc.0"></script><script src="/js/header.js?v=2.0.0-rc.0"></script><script src="/js/sidebar.js?v=2.0.0-rc.0"></script></body></html>